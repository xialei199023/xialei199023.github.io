<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[2016年年终总结]]></title>
      <url>%2F2017%2F01%2F25%2F2016-final-summary%2F</url>
      <content type="text"><![CDATA[今天是2017年1月25日，农历12月28，再过一天就要跟宝宝一起踏上回家的火车，跟家里人过年团圆了！这篇文章本应该在公元2016年年底撰写，但是，由于一些原因导致并没有完成。 客观上，前一段时间因为项目原因，非常地忙。几乎每天都要加班到很晚，生理和心理上都比较疲惫。平常下完班到家一般都10点多了，洗洗差不多就可以睡觉了。虽然周末基本上不加班了，但是心理上的疲惫让人喘不过气来，已经没有心情花上时间去写这篇文章了。 主观上，我已经变得越来越懒惰了，除了上面所说的可观原因外，内心对学习、写文章这种事情出现了抗拒心理。对笔者来说，这是一种非常糟糕的状态。以前信誓旦旦地说要不忘初心，现如今却因为走的太快，而忘了自己为什么出发了！ 借着闲余之际，在猴年即将过去、鸡年向我们走来的时候，来好好总结一下2016年的成功、失败、收获和失去。 2016年的经历2016年应该应该说是不同寻常的一年，这年里我一共经历了3家公司，这是难以理解的，也不在我的计划之内的。 2016-01~2016-03，在一家创业公司做软件开发。公司面向出版行业，主要的客户都在北京，广州只做研发。由于对公司的前景不是和看好，所以主动辞职离开了。 2016-03~2016-08，在一家大型酒店服务行业公司做软件开发，主要的工作是面向外部OTA作接口的开发和对接。公司的氛围和文化我还是比较认同的，原本打算在这家公司长久的做下去，但是后来被同学打动，跳到了另外一个初创型公司。 2016-08~现在，被同学挖到一家初创型公司，主要的客户是广东省国有企业和事业单位。在这里，除了继续软件开发外，还要担任架构和设计工作，对自己提出了更高的要求。 第3次跳槽并不在我原本的计划范围内，但是这就是选择，从目前来看，我觉得我的选择是正确的！ 2016年的收获2016年是我毕业参加工作以来收获最大的一年，无论从工作上、家庭上还是个人成长上都有了质的变化。可以说是我生命中的又一个转折点，必定会对我今后的人生路产生特别重要的影响。 自己的小窝2016年6月，在东偏西凑之后，终于在广州郊区购买了一套属于自己的房子。房子虽然比较小（60多平米），但是终于有了属于自己的地方，也算是在广州扎下了根。说了购房过程，概括为“一蹴而就”。之前在周末的时候也是会去看看房（主要在花都），但是都没有下定决心入手一套。一来是首付确实还不够，二来本身购房的需求没有那么强烈。后来第2家公司的同事看完房之后，就推荐我去山景城看看，他说非常适合我。之所以他会认为适合我，也我是跟他提及过我目前的状况和需求。后来趁着周末去看了一下，没想到一眼看中，而且价格也比较合适。最后借了点、贷了点就把首付款给搞定了^_^。 虽然房子的地理位置并不太好，房子也比较小，而且是期房，但是却让我有了奋斗的动力，也看到了生活的希望！ 驾照经过了1年多的时间，终于在2016年12月份把该死的驾照拿到手了。除了科目三挂了一次之外，其他科目都是有惊无险。钱包里面的空位算是填齐了。驾照到手了，车子还会远吗？！ 为之奋斗的事业2016年8月份来到了现在这家公司，除了开发之外，还兼职后台架构。从目前来看，公司和项目都是靠谱的。公司从2015年开始成立，经过半年多的摸索，重要找到了自己的方向和业务范围。在这期间人员逐渐增长，也逐步在往专业化的方向发展。 虽然项目比较紧，加班比较对，但是，团队成员都在朝着同一个方向努力和奋斗。每周三都有下午茶，中午一局LOL（手游版），公司的文化很有活力，就像早晨8、9点钟的太阳，朝气蓬勃向上。我想我找到了我的事业，想为之去奋斗和拼搏，这应该是我2016年最大的收获！ 2016年的失去有得必有失，2016年我也失去了一些东西。 业余学习的热情由于经常性的加班，业余时间比之前少了很多。最近一篇文章还是2016-09-21写的，而且还是一篇索引。我在2016年后半段逐渐失去了学习的热情，周末基本上在玩Dota，没有看书、没有写文章，没有保持学习和提高。我最近有点迷失，忘了自己的初心！ 我的职业目标是成为一名优秀的架构师，为此我必须要不断地学习，从深度和广度上不断地专研。 健康2016年，我的健康状况明显下降。一方面，加班太多，消耗了太多的精力；另一方面，自己越来越懒惰，基本上没有什么运动。一到周末不是躺着，就是坐着打游戏。身体状况每况愈下，这给自己敲响了警钟。新的一年，我必须得勤加锻炼！ 2017年的小目标辞旧迎新，2017年是新的开始，我也要重新开始出发。2016年流行“小目标”这个词，这源于首付王健林在一次访谈中说的话。2017年我也有一些小目标： 成为真正的架构师。 搬进新家，娶老婆。 摇到号买个车。 身体健康。 本文由xialei原创，转载请说明出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[温故知新——关系型数据库学习索引]]></title>
      <url>%2F2016%2F09%2F21%2Flearn-database-index%2F</url>
      <content type="text"><![CDATA[数据库基础 基本概念 数据表设计 SQL语言 MySQL数据库 MySQL基础 MySQL命令 索引和慢查询 锁 Mysql集群 本文由xialei原创，转载请说明出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新认识java——线程（Thread）]]></title>
      <url>%2F2016%2F09%2F17%2Frelearn-java-thread%2F</url>
      <content type="text"><![CDATA[多线程编程是开发者必须要掌握的基本技能，线程（Thread）是基础和核心。只有深刻地理解Java线程，才能写出合理、高效的多线程代码。本文将研究Java中的线程，同时会捎带部分操作系统相关内容。主要的内容如下： 进程与线程 Java线程(线程创建、Thread中的主要方法、线程通信) 进程与线程进程与线程，是操作系统中的重要概念，稍微有点计算机基础的开发者都会听说过、接触过。 进程（Process）：计算机中的程序关于某数据集合上的一次运行活动，是操作系统结构的基础（来自百度百科）。狭义上来说，进程是正在运行的程序实例。进程和程序间的关系很微妙，用一个比喻（来自《现代操作系统》）来说明。有一位拥有一手好厨艺计算机科学家正在为女儿烘制蛋糕，他有制作蛋糕的食谱，还有一些原料（面粉、鸡蛋等）。在这个例子中，食谱就是程序（用适当形式描述的算法），科学家就是CPU，原料就是各种输入数据。那么，进程就是食谱、原料以及烘制蛋糕的系列动作的总和。 线程（Thread）：有时也被称为轻量级进程，是程序调度和执行的最小单元。线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个进程可以包含多个线程，而一个线程只能属于唯一的进程。 已经有了进程，为什么还会需要线程呢？主要原因如下： 许多应用程序中，同时发生着多个活动。将这些应用程序分解成多个准并行的线程，程序设计的模型会变成更加简单。 由于线程比进程进行更加轻量，创建和取消更加容易。 如果程序是IO密集型，那么多线程执行能够加快程序的执行速度。（如果是CPU密集型，则没有这个优势） 在多CPU系统中，多线程是可以真正并行执行的。 Java线程线程状态 新建状态（New）：线程对象已经创建，还没有在其上调用start()方法。 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 创建和启动线程Java中有两种方法定义线程： 1、继承java.lang.Thread类。 123456789101112/** * 进程Thread类定义线程。 * @author xialei * @version 1.0 2016年8月1日下午9:22:37 */public class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println("Hello"); &#125;&#125; 上面的代码继承了java.lang.Thread类，然后重写了run()方法。该方法的方法体内是线程需要完成的任务，称为线程执行体。下面的代码启动这个线程： 12MyThread myThread = new MyThread();myThread.start(); 通过调用Thread类中的start()方法启动线程，这方法最终会调用start0()native方法启动线程。调用start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。 2、实现java.lang.Runnable接口。 12345678910111213/** * 实现Runnable接口定义线程。 * @author xialei * @version 1.0 2016年8月1日下午9:28:28 */public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println("Hello"); &#125;&#125; 调用下面的代码可以启动线程。 12Thread thread = new Thread(new MyRunnable());thread.start(); MyRunnable类本身并不能启动线程，而是需要实例化一个Thread类来启动线程。可以看到，不管是哪种方法，都是调用Thread的start()方法来启动的。Thread类和Runnable接口到底是什么关系呢？实际上，Thread类本身就实现了Runnable接口，Thread中的run()就是实现了Runnable中的run()方法，其代码如下： 12345public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 通过Thread(Runnable)构造方法可传入Runnable对象，然后直接调用其run()方法。 线程类型Java中的线程有用户（User）线程和守护(Daemon)线程两类。我们默认创建的线程是用户（User）线程，守护线程–也称“服务线程”，在没有用户线程可服务时会自动离开。只要当前JVM实例中尚存在任何存货的用户线程，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。 下面来分别演示一下这两类线程。 123456789101112131415public class UserThreadTest &#123; public static void main(String[] args) &#123; Thread t = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("i=" + i); &#125; &#125; &#125;; t.start(); &#125;&#125; 上面创建一个默认线程（用户线程），在任务是打印出0~10，上面的运行结果如下： 12345678910i=0i=1i=2i=3i=4i=5i=6i=7i=8i=9 12345678910111213141516public class UserThreadTest &#123; public static void main(String[] args) &#123; Thread t = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("i=" + i); &#125; &#125; &#125;; t.setDaemon(true); // 将线程设置为守护线程 t.start(); &#125;&#125; 上面创建一个守护线程，与上面的程序执行同样的任务。最终的结果（可能每台机器会有差异）是程序结束时什么都没打印。main函数是Java程序的入口，在启动程序时会同时启动一个main线程来执行main函数中的代码。main线程是一个用户线程，当执行完t.start()代码后，main就已经运行完毕了。此时，该程序不存在任何存活的用户线程，在t还没来得及运行时，程序就直接终止了。 Java垃圾回收线程就是一个典型的守护线程，当我们的程序中不再有任何运行中的用户线程时，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。 线程通信每个Java线程独享执行栈、程序计数器等资源。在多核处理器中，多线程可以真正的并行运行，相较单线程程序，其运行效率大大提高。理想情况下，每个线程应该是独立运行的，多个线程之间不会牵扯。但是，在实际应用中，存在线程依赖或排斥等需求，如消费者线程和生产者线程。这时候就需要线程通信机制，来保证多线程程序“安全”运行。下面介绍Java中的主要线程通信方式：线程同步和wait/notify机制。 线程同步同步中的“同”应为协同、协助、互相配合之意。所谓线程同步，是指多个线程协同完成一个任务。Java中的可以实现同步的方法包括synchronized以及其他的锁（如ReetrantLock），其中synchronized是Java中的关键字。本节所指的线程同步特指使用synchronized关键字实现的线程同步。 下面的例子是2个线程使用同一个变量count进行计数，每个线程均计1000次。如果正常的话，可以预期count变量最终的值应该是2000。在运行多次之后，count最终的值出现了1998、1999、2000等情况。出现这种结果的原因是++count操作不是原子的，会编译成多条指令。 1234567891011121314151617181920212223242526272829303132public class ThreadCommunication1 &#123; private static int count = 0; public static void main(String[] args) &#123; // 开两个线程，同时对count变量进行累加1000次。正常情况下，最后count应该等于2000。 // 但是，实际运行情况是，多次运行之后，最后会出现count=1998、1999、2000等情况。 new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("thread:" + this.getName() + ",count=" + (++count)); &#125; &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("thread:" + this.getName() + ",count=" + (++count)); &#125; &#125; &#125;.start(); &#125;&#125; 这种情况就需要多个线程协同执行，线程之间商量好，我执行的时候其他线程都等着，等我执行完了之大家再继续执行。下面的代码加上了synchronized关键字。 123456789101112131415161718192021222324252627282930313233public class ThreadCommunication1 &#123; private static int count = 0; public static void main(String[] args) &#123; new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; synchronized (ThreadCommunication1.class) &#123; // 这里加了同步代码 System.out.println("thread:" + this.getName() + ",count=" + (++count)); &#125; &#125; &#125; &#125;.start(); new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; synchronized (ThreadCommunication1.class) &#123; // 这里加了同步代码 System.out.println("thread:" + this.getName() + ",count=" + (++count)); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 上面的代码将++count操作包裹synchronized程序块内，同一时间只能有一个线程对象（ThreadCommunication1.class）的锁。在上面的代码无论运行多少次，count最终的结果都是2000。Java中的synchronized包含了互斥的语义，无论什么操作，同一时间内，只有一个线程可以获得同步锁并执行。使用synchronized只能实现排他锁，无法直接实现共享锁。 wait/notify机制Java中的继承关系是一种树形结构，树的根节点就是Object类，其他所有的类（或接口）都是从这个类派生出来的。Object类中定义了一些与线程通信相关的方法： wait()：当前线程放弃自己所持的锁，并进入等待状态。 notify()：唤醒正在处理等待（wait）状态的某一个线程。 notifyAll()：唤醒正在处于等待（wait）状态的所有线程。 上面的方法是本地（native）方法，或者间接调用本地方法。在使用这些线程通信方法时有些要特别注意的点。 （一）在调用这些方法之前，当前线程必须持有对象的锁。从源代码层面上来说，这些方法必须包含在synchronized代码块内部。 123456789101112131415public class WaitWithoutSync &#123; public void dothing() &#123; try &#123; this.wait(); // 直接调用wait方法。 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; WaitWithoutSync waitWithoutSync = new WaitWithoutSync(); waitWithoutSync.dothing(); // 抛出java.lang.IllegalMonitorStateException &#125;&#125; 上面是直接调用wait()方法的一段代码，运行后抛出java.lang.IllegalMonitorStateException异常。正确的调用方法如下： 1234567891011121314151617public class WaitWithoutSync &#123; public void dothing() &#123; synchronized (this) &#123; // 将wait方法由对应的同步块包裹起来 try &#123; this.wait(); // 直接调用wait方法。 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; WaitWithoutSync waitWithoutSync = new WaitWithoutSync(); waitWithoutSync.dothing(); // 抛出java.lang.IllegalMonitorStateException &#125;&#125; （二）当调用notify()或者notifyAll()方法后并不会立刻释放锁，而是要等到同步块内部的代码全部运行完毕后才会释放锁并唤醒等待线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class NotifyTest &#123; private Object lock = new Object(); private void await() &#123; synchronized (lock) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("wait完毕 "); &#125; &#125; private void anotifyAll() &#123; synchronized (lock) &#123; lock.notifyAll(); System.out.println("notify完毕 "); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("睡眠5秒钟...."); &#125; &#125; public static void main(String[] args) &#123; final NotifyTest notifyTest = new NotifyTest(); new Thread() &#123; // 启用一个线程，调用等待方法 @Override public void run() &#123; notifyTest.await(); &#125; &#125;.start(); new Thread() &#123; // 启用另外一个线程，调用唤醒方法 @Override public void run() &#123; notifyTest.anotifyAll(); &#125; &#125;.start(); &#125;&#125; 上面代码的运行结果如下： 123notify完毕 睡眠5秒钟....wait完毕 也就是说，在调用lock.notifyAll();方法之后并没有立刻唤醒等待线程，而是待同步块内的逻辑全部运行完毕之后，才会真正地唤醒等待线程。 （三）notify和notifyAll的区别 notifyAll：使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。notify：只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，当第一个线程运行完毕以后释放对象上的锁此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll，它们等待的是被notify或notifyAll，而不是锁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class NotifyTest2 &#123; private void anotify() &#123; while (true) &#123; try &#123; Thread.sleep(4000); System.out.println("等待4秒结束"); synchronized (this) &#123; this.notify(); System.out.println("notify完毕"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void await() &#123; synchronized (this) &#123; try &#123; System.out.println("开始wait"); this.wait(); System.out.println("wait完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; final NotifyTest2 notifyTest2 = new NotifyTest2(); new Thread() &#123; // 创建一个notify线程 @Override public void run() &#123; notifyTest2.anotify(); &#125; &#125;.start(); new Thread() &#123; // 创建一个wait线程 @Override public void run() &#123; notifyTest2.await(); &#125; &#125;.start(); new Thread() &#123; // 创建一个wait线程 @Override public void run() &#123; notifyTest2.await(); &#125; &#125;.start(); new Thread() &#123; // 创建一个wait线程 @Override public void run() &#123; notifyTest2.await(); &#125; &#125;.start(); &#125;&#125; 上面的anotify()方法循环调用notify方法，每次调用完毕后，休眠4秒钟。主线程中调起一个notify线程和3个wait线程，由于休眠了4秒钟后才会第1次执行notify方法，所以在这之前，3个wait线程都会执行完wait()方法并阻塞当前线程。当执行notify()方法后，唤醒一个wait线程。所以最终的执行结果如下： 123456789101112开始wait开始wait开始wait等待4秒结束notify完毕wait完毕等待4秒结束notify完毕wait完毕等待4秒结束notify完毕wait完毕 下面将notify()方法改为notifyAll()方法，其他代码均不变。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class NotifyTest2 &#123; private void anotify() &#123; while (true) &#123; try &#123; Thread.sleep(4000); System.out.println("等待4秒结束"); synchronized (this) &#123; this.notifyAll(); // 这里改为调用notifyAll方法 System.out.println("notify完毕"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void await() &#123; synchronized (this) &#123; try &#123; System.out.println("开始wait"); this.wait(); System.out.println("wait完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; final NotifyTest2 notifyTest2 = new NotifyTest2(); new Thread() &#123; // 创建一个notify线程 @Override public void run() &#123; notifyTest2.anotify(); &#125; &#125;.start(); new Thread() &#123; // 创建一个wait线程 @Override public void run() &#123; notifyTest2.await(); &#125; &#125;.start(); new Thread() &#123; // 创建一个wait线程 @Override public void run() &#123; notifyTest2.await(); &#125; &#125;.start(); new Thread() &#123; // 创建一个wait线程 @Override public void run() &#123; notifyTest2.await(); &#125; &#125;.start(); &#125;&#125; 由于第一次调用notifyAll()方法后，3个wait线程均已经被唤醒，此时只需争用到锁即可以继续执行，而无需再次被唤醒。上面的代码的执行结果如下： 12345678开始wait开始wait开始wait等待4秒结束notify完毕wait完毕wait完毕wait完毕 Thread中的重要方法Thread.sleep(time)：放弃CPU机会，等待time时间后，线程变成可运行状态。值得注意的是，如果当前线程持有锁，执行这个方法并不会释放锁。Thread.yield()：让出CPU，使得有相同优先级的线程有机会执行。大多数情况下，将线程从运行状态转为可运行状态，然而，下次仍有可能运行这个线程。threadInstance.join()：将线程threadInstance加入当前运行线程，只有当threadInstance运行完毕之后，当前线程才能继续往下运行。 本文由xialei原创，转载请说明出处http://hinylover.space/2016/09/17/relearn-java-thread/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新认识Java——容器体系（Collection）]]></title>
      <url>%2F2016%2F07%2F23%2Frelearn-java-collection%2F</url>
      <content type="text"><![CDATA[Java中的容器在开发过程必然会接触到的，也是作为一名合格的Java程序员必须要掌握的内容。各种面试、笔试中十有八九都会在容器上面做“文章”。由于每一类容器涉及的知识点都比较多，基于单一职责原则，本文并不会对特定容器做特别深入地介绍。文章在宏观层面上来研究一下Java中的容器体系，并比较各种容器之前的联系与区别，主要内容如下： Java容器的体系结构 Collection体系 Map体系 容器的体系结构Java中的容器主要有Collection和Map，它们都是顶层接口，都位于java.util包下，实际使用地容器都是基于这两个接口延伸出来的。下面来看看在实际开发过程中使用的主要类的类图（基于JDK1.8），并简单地介绍它们的功能。 下面是Collection接口的类图： List：是一种已知顺序的有序数据集，可容纳重复的元素。 Set：是一种数学意义上的集合，最大的特点是不可容纳重复元素。 Queue：即队列，与经典数据结构的队列一致。 下面是Map接口的类图： HashMap：即哈希表，与经典数据结构中哈希表一致，主要用于快速查找。 HashTable：与HashMap功能基本一致，不过是线程安全的。 SortedMap：经过排序的Map。 ConcurrentMap：并发Map，主要用于多线程并发环境下。 CollectionCollection实现了Iterable（迭代器）接口，意味着其子类都可以利用迭代器模式来访问其中的元素。所以，我们可以用for…each…方式要顺序读取Collection中的元素，类似下面的代码： 1234567public static void main(String[] args) &#123; Collection&lt;String&gt; c = new ArrayList&lt;String&gt;(); c.add("1"); for (String s : c) &#123; System.out.println(s); &#125;&#125; 这种写法实际上不属于Java的原生语法，而是一种语法糖。它最终编译后的字节码主体部分为： 12345678910111213141516171819202122232425262728public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: new #16 // class java/util/ArrayList 3: dup 4: invokespecial #18 // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: ldc #19 // String 1 11: invokeinterface #21, 2 // InterfaceMethod java/util/Collection.add:(Ljava/lang/Object;)Z 16: pop 17: aload_1 18: invokeinterface #27, 1 // InterfaceMethod java/util/Collection.iterator:()Ljava/util/Iterator; 23: astore_3 24: goto 44 27: aload_3 28: invokeinterface #31, 1 // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object; 33: checkcast #37 // class java/lang/String 36: astore_2 37: getstatic #39 // Field java/lang/System.out:Ljava/io/PrintStream; 40: aload_2 41: invokevirtual #45 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 44: aload_3 45: invokeinterface #51, 1 // InterfaceMethod java/util/Iterator.hasNext:()Z 50: ifne 27 53: return 看上面字节码中的第15行，它调用了Iterator接口中定义的iterator()方法来获取一个Iterator的实例。然后分别用next()和hasNext()来进行循环来读取Collection中保存的元素，这是Java中迭代器的典型用法。 所有实现Collection接口的类都必须提供两个标准的 构造函数： 无参数的构造函数用于创建一个空的Collection。 有一个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。 ListList是一类顺序已知的数据集，元素存放的逻辑顺序完全由调用者控制，并且可以存放重复元素（equals比较后返回true的元素）和null元素。调用者能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。 List除了可以利用iterator()返回一个Iterator示例外，还定义了listIterator()方法来返回一个ListIterator实例。ListIterator接口继承了Iterator接口，它定义删除、添加和向前索引元素等方法。 List接口的主要子（孙）类有：ArryList、LinkedList和Vector，他们主要的区别如下表： List 线程安全性 扩容时是否需要复制 是否可以指定初始容量 ArrayList 非线程安全 是 是 LinkedList 非线程安全 否 否 Vector 线程安全 是 是 Vector已经很少被用到了，下面仅比较ArryList和LinkedList的各种操作效率，然后介绍其使用场景。 List add get remove 占用空间 内存空间是否连续 ArrayList 时间复杂度：O(n) 时间复杂度：O(1) 时间复杂度：O(n) 元素占用空间和 连续 LinkedList 时间复杂度：O(1) 时间复杂度：O(n) 时间复杂度：O(n) 元素占用空间和+指针空间 可以不连续 从上面可以看出，ArryList和LinkedList各自有其优势和劣势，他们的使用场景可以总结为： 如果待容纳的元素总量确定，则优先使用ArryList； 如果读操作大于写操作，则使用ArryList；反之，则使用LinkedList。 SetSet表示数学意义上的集合，它不允许重复的元素，即任意的两个元素e1和e2都有e1.equals(e2)为false。Set最多允许一个null元素，Set的构造函数有一个约束条件，传入的Collection实例不能包含重复的元素。实际使用较多的子类有：HashSet和TreeSet。 Set的实现类基本上都是基于Map来实现的，它巧妙地利用了Map中的key不会重复的特性。HashSet是基于HashMap实现的，而TreeSet默认是基于TreeSet实现的。它们的区别如下： Set 元素有序性 是否支持排序 HashSet 无序 不支持排序 TreeSet 有序 支持排序 如果无需保证取出的元素序列与插入的元素序列顺序完全一致，则使用HashSet；反之，则应该使用TreeSet。 Queue队列是一种先进先出的数据结构．它有两个基本操作：在队列尾部加人一个元素，从队列头部移除一个元素。由于笔者在实际开发过程极少会用到这种数据结构，或者会使用额外的消息队列来替代，所以暂时将这部分内容先放一放。LinkedBlockingQueue、ArrayBlockingQueue等阻塞式队列广泛用于Java并发库中，在学习j.u.c包时再深入地研究。 Map体系Map是一种把键和值进行映射的集合，其中的每个元素都是Map.Entry实例。Map的主要功能是通过键（key）快速查找出值（value）。主要有两种方法对Map进行遍历： 第一种，先获取entrySet，然后利用迭代器遍历这个对象。 1234567Map map = new HashMap();Iterator iter = map.entrySet().iterator();while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue();&#125; 第二种，先获取Map的迭代器，每次取出一个key，然后查找每个key所对应的value。 123456Map map = new HashMap();Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; Object key = iter.next(); Object val = map.get(key);&#125; 很显然，第一种遍历方式效率更高，推荐使用。 Map的子类非常多，使用频率较高的是下面4个： HashMap：最接近数据结构中的哈希表的实现，采用拉链法解决key冲突。前面的HashSet即使基于这个类来实现的。 HashTable：线程安全版的HashMap。 LinkedHashMap：HashMap的子类，利用链表解决HashMap中遍历时，输出的元素顺序与插入顺序不一致的问题。 TreeMap：与TreeSet的特点类似，可以对key进行排序。 Map是Java中的非常重要的数据结构，上面的几种实现各有侧重，通过下面的表格来看看它们各自的特点： Map 线程安全 达到容量上限时内存拷贝 是否允许null key 遍历顺序 是否可排序 HashMap 否 需要 是 无序 否 HashTable 是 需要 否 无序 否 LinkedHashMap 否 需要 是 与输入顺序一致 否 TreeMap 是 不需要 否 与输入顺序一致 是 在这4个类中，HashMap和TreeMap2中场景，下面介绍不同场景下该使用哪种Map。 HashMap：插入、删除和定位元素的平均时间复杂度为O(N)，是一个常数时间。如果没有排序需求，则应该优先使用HashMap。 Treemap：插入、删除和定位元素的平均时间复杂度为O(log(n))适用于按自然顺序或自定义顺序遍历键(key)。 总结本文简单地介绍了Java中的主要容器体系，内容非常浅。深入了解Java各个容器的内部原理和实现方式是Java程序员进阶的必经之路。在今后的学习中，笔者会研读这些容器类的源代码，并将学习笔记发布上来。 本文由xialei原创，转载请说明出处http://hinylover.space/2016/07/23/relearn-java-collection/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新认识Java——字符串（String）]]></title>
      <url>%2F2016%2F07%2F10%2Frelearn-java-string%2F</url>
      <content type="text"><![CDATA[对于任何变成语言来说，接触字符串都是不可避免，Java也不例外。Java中String类位于java.lang包下，是整个Java语言的基石。同时String类使用final关键词修饰，意味着外部调用者无法通过继承和重写来更改其功能。Java中的字符串与语言相比，也有其特殊性。本文深入地理解Java字符串，主要内容有： String的初始化 String与常量池 String的不变性 String、StringBuffer与StringBuilder “+”操作符 String初始化首先要强调的是，String并不是Java中的基础类型，它也是一个对象。在源代码层面来说，String有多种不同的初始化方法，本节就介绍这些初始化方法。 字面量法String的字面量初始化法如下所示： 12String a = "abc";String b = "hello world"; 这种方法首先从常量池中查找是否有相同值的字符串对象，如果有，则直接将对象地址赋予引用变量；如果没有，在首先在常量池区域中创建一个新的字符串对象，然后将地址赋予引用变量。 构造方法法String的构造方法初始化法如下所示： 12String a = new String("abc");String b = new String("hello world"); String类的构造方法有： 12345public String() &#123;&#125; // 构造空串（注意与null的区别）public String(String original) &#123;&#125; // 基于另外一个字符串构造一个新字符串对象public String(char value[]) &#123;&#125; // 使用byte数组构造字符串public String(char value[], int offset, int count)&#123;&#125; // 使用byte数组以及偏移参数构造public String(int[] codePoints, int offset, int count) &#123;&#125; // 基于Uncode编码数组以及偏移量构造 这种初始化方法与一般对象的初始化方法完全一样。与字面量法不同的是，每次调用构造方法都会在堆内存中创建一个新的字符串对象。下面的例子可以清楚地显示它们的区别： 123456789101112131415161718192021222324/* * 个人主页：http://hinylover.space * * Creation Date: 2016年7月6日 下午9:14:56 */package demo.blog.java.string;/** * 不同初始化方法的区别。 * @author xialei * @version 1.0 2016年7月6日下午9:14:56 */public class StringEqual &#123; public static void main(String[] args) &#123; String a1 = "123"; String b1 = "123"; System.out.println(a1 == b1); // true String a2 = new String("123"); String b2 = new String("123"); System.out.println(a2 == b2); // false &#125;&#125; 我们知道，Java中的“==”符比较的变量保存的实际内存数据，由于基础数据类型变量保存的是数据的实际值，而引用类型变量保存的是对象的地址，不同的地址代表着不同的对象。a1 == b1为true表明a1和b1指向同一个对象，而a2和b2分别指向不同的对象。 String与JVM常量池说起String ，就不能不提到JVM常量池，是笔试和面试中经常喜欢出题的点。 常量池在正式进入常量池之前，首先简单地介绍一下JVM（Java虚拟机，由于市面上有多种不同的JVM，本文中仅考虑Hotspot VM）的内存结构，也是作为Java程序员必须要了解的内容（以后再深入JVM）。由于本文的主体并不是Java虚拟机，内容会比较粗糙，更加详细的JVM知识会在以后撰写。 JVM的内存顶层结构如下图所示： 下面分别来说说主要的内存区域： 程序计数器：这是一块比较小的内存区域，可以看做是当前线程所执行的字节码的行号指示器。每一个线程都会需要有一个独立的程序计数器，各个程序计数器之间相互不影响。如果线程当前执行的是Java方法，则计数器记录当前正在执行字节码指令地址，如果是Native方法，则计数器的值为空。 栈区：栈区是线程私有的，其生命周期与线程相同。栈区描述的是Java方法执行的内存模型（以后会详细研究）。 本地方法栈：功能与栈区的功能相似，不过是为Java中的Native方法服务的。 堆区：这是JVM管理的最大的一块内存区域，是所有线程共享的，几乎所有的对象实例都放置在这个区域。堆又可以细分为：年轻代、老年代。我们通常所说的垃圾回收就是发现在这个内存区域。 方法区：与堆一样，也是所有线程所共享的。由于习惯问题，方法区也被叫做永久代，因为上面放置的数据很难被回收（条件很苛刻）。 常量池（准确地说是运行时常量池），在JDK1.6及以前都是方法区中的一部分，在JDK1.7之后被移入堆区，用来存放编译时生成的各种字面量和符号引用。下面来看一下普通类编译后的字节码。 123456public class Test &#123; public static void main(String[] args) &#123; String a = "123"; &#125;&#125; 上面的源代码编译完后的字节码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#13 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = String #14 // 123 #3 = Class #15 // Test #4 = Class #16 // java/lang/Object #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Utf8 LineNumberTable #9 = Utf8 main #10 = Utf8 ([Ljava/lang/String;)V #11 = Utf8 SourceFile #12 = Utf8 Test.java #13 = NameAndType #5:#6 // &quot;&lt;init&gt;&quot;:()V #14 = Utf8 123 #15 = Utf8 Test #16 = Utf8 java/lang/Object&#123; public Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 4: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=2, args_size=1 0: ldc #2 // String 123 2: astore_1 3: return LineNumberTable: line 7: 0 line 8: 3&#125; 第6~21行是编译后产生的常量池（编译时常量池），这些常量在类加载时被保存到运行时常量池中，代码中123字符串在编译后放入常量池中（见第19行），这也就解释了上一节示例中的a1 == b1为true的问题。常量池中的大部分数据都来自编译时常量池，也可以在运行时将数据放入常量池。 intern()方法intern()方法的作用是在常量池中查找值等于（equals）当前字符串的对象，如果找到，则直接返回这个对象的地址；如果没有找到，则将当前字符串拷贝到常量池中，然后返回拷贝后的对象地址。下面的代码可以解释intern()的功能。 12345678String a = "123";String b = new String("123");String c = new String("123");System.out.println(a == b); // falseSystem.out.println(a == b.intern()); // trueSystem.out.println(c == b.intern()); // falseSystem.out.println(c.intern() == b.intern()); // true 由于String a = “123”;产生的字符串对象会直接放入常量池中，当调用b.intern()方法时，由于已经存在值为123的对象（即a所指向的对象），直接返回这个对象，所以a == b.intern()判定为true。 String的不可变性类的不可变性什么叫做类的不变性？简单地说，就是其实例一旦创建完成，在其整个生命周期内状态都不会发生变化。状态这个词有一些抽象，在Java中对象的状态是由其成员变量来表现的，那么状态不变即是成员变量不变（具体来说，基本类型变量的值不变、引用类型变量的引用地址不变）。不可变的类有不少好处： 更加易于设计、实现和使用。 并发时，不容易出错，并且更加安全。 为了使类成为不可变，要遵循下面五条规则（引用自《Effective Java》）： 不提供任何会修改对象状态的方法； 保证类不能被扩展； 所有的成员变量都被final修饰的； 所有的成员变量都是private的； 确保对于任何可变组件的互斥访问。如果一个类的成员变量引用了可变对象，则必须确保外部调用类无法获取指向这些对象的引用。 当然，所有的这些条件都是针对正常调用而言的，如果使用反射，则仅仅满足上述的条件也无法保证对象不可变。 String的不可变性首先来通过一个图文案例来说明String不可变性。 1、声明一个String类型变量。 1String s = "abcd"; 2、将字符串变量赋予另外一个String类型变量。 1String s2=s; 3、连接另外一个字符串对象。 1String s3 = s.concat("ef"); 可以看到s3指向是另外一个对象，而不是原来a所指向的对象。在调用concat(String)方法之后，a所指向的对象状态并没有发生改变，而是生成了一个新的对象。下面是concat(String)方法的源代码（JDK1.8）： 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125; 注意到第9行代码，它直接创建一个新的String对象。 为什么String要设计为不可变呢？主要原因如下： 字符串池（String pool）的需求。之前已经说过，通过字面量发初始化一个Java字符串时，会将这个字符串保存在常量池中。如果定义了另外一个相同值的字符串变量，则直接指向之前初始化的那个对象。如果字符串是可变的，改变另一个字符串变量，就会使另一个字符串变量指向错误的值。 缓存字符串hashcode码的需要。字符串的hashcode是经常被使用的，字符串的不变性确保了hashcode的值一直是一样的，在需要hashcode时，就不需要每次都计算，这样会很高效。 出于安全性考虑。字符串经常作为网络连接、数据库连接等参数，不可变就可以保证连接的安全性。 String、StringBuffer与StringBuilderStringBuffer与StringBuilder是创建字符串常用的类，采用构建器模式来构建字符串对象，使得可以在运行时动态地构建字符串对象。下表是它们各自的特点。 类 可变性 线程安全 String 不可变 线程安全 StringBuffer 可变 线程安全 StringBuilder 可变 非线程安全 “+”操作符String是一个异类，除了基本类型及其包装类之外，只有它可以使用”+” 操作符号。在String中，”+” 表示字符串连接，而不是数学运算中的加法运算。下面通过一些例子（例子引用自《深入理解Java：String》）来说明不同场景下使用”+”操作符的特点。 编译时优化12345678/* * 由于常量的值在编译的时候就被确定(优化)了。 * 在这里，"ab"和"cd"都是常量，因此变量str3的值在编译时就可以确定。 * 这行代码编译后的效果等同于： String str3 = "abcd"; */ String str1 = "ab" + "cd"; String str11 = "abcd"; System.out.println("str1 = str11 : "+ (str1 == str11)); // true 为了提高效率和减少内存占用，Java编译器会在编译时做一些其力所能及的事情。上面的代码中，由于在编译时即可以确定str1的值为”abcd”，所以编译时，直接将”abcd”字符串对象赋予str1，所以str1和str11引用的是常量池中的同一个对象。 利用StringBuilder实现123456789101112131415161718192021/* * 局部变量str2,str3存储的是存储两个拘留字符串对象(intern字符串对象)的地址。 * * 第三行代码原理(str2+str3)： * 运行期JVM首先会在堆中创建一个StringBuilder类， * 同时用str2指向的拘留字符串对象完成初始化， * 然后调用append方法完成对str3所指向的拘留字符串的合并， * 接着调用StringBuilder的toString()方法在堆中创建一个String对象， * 最后将刚生成的String对象的堆地址存放在局部变量str3中。 * * 而str5存储的是字符串池中"abcd"所对应的拘留字符串对象的地址。 * str4与str5地址当然不一样了。 * * 内存中实际上有五个字符串对象： * 三个拘留字符串对象、一个String对象和一个StringBuilder对象。 */ String str2 = "ab"; String str3 = "cd"; String str4 = str2 + str3; String str5 = "abcd"; System.out.println("str4 = str5 : " + (str4 == str5)); // false 上面的源代码编译后的字节码如下，第5行创建了一个StringBuilder对象，并在第9行和第11行分别将字符串”ab”和”cd”append到对象中，生成新的字符串对象”abcd”，并将引用赋予变量str4。str5引用的对象保存在常量池中，而str4引用的对象是保存在Java堆中的，它们不是同一个对象。 12345678910111213141516171819202122232425262728293031 0: ldc #2 // String ab 2: astore_1 3: ldc #3 // String cd 5: astore_2 6: new #4 // class java/lang/StringBuilder 9: dup10: invokespecial #5 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V13: aload_114: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;17: aload_218: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;21: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;24: astore_325: ldc #8 // String abcd27: astore 429: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream;32: new #4 // class java/lang/StringBuilder35: dup36: invokespecial #5 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V39: ldc #10 // String str4 = str5 :41: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;44: aload_345: aload 447: if_acmpne 5450: iconst_151: goto 5554: iconst_055: invokevirtual #11 // Method java/lang/StringBuilder.append:(Z)Ljava/lang/StringBuilder;58: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;61: invokevirtual #12 // Method java/io/PrintStream.println:(Ljava/lang/String;)V64: return final字符串编译时优化123456789/* * JAVA编译器对string + 基本类型/常量 是当成常量表达式直接求值来优化的。 * 运行期的两个string相加，会产生新的对象的，存储在堆(heap)中 */ final String str8 = "b"; String str9 = "a" + str8; String str89 = "ab"; System.out.println("str9 = str89 : "+ (str9 == str89)); // true //↑str8为常量变量，编译期会被优化 用final修饰的变量str8表示字符串常量，str8不可能引用其他的字符串。在编译时，直接将”ab”字符串赋予str9变量，所以，上面的判断结果为true。 参考文献 《深入理解Java虚拟机 JVM高级特性与最佳实践》《Effective Java》深入理解Java：String 本文由xialei原创，转载请说明出处http://hinylover.space/2016/07/10/relearn-java-string/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新认识Java——泛型（通配、特性和注意点）]]></title>
      <url>%2F2016%2F07%2F03%2Frelearn-java-generic-2%2F</url>
      <content type="text"><![CDATA[上一篇文章介绍了Java泛型中的基础及原理，本文将继续研究有关Java泛型的内容。本文的主要内容有： 泛型的特性 泛型通配 泛型类与普通类的不同点，也是日常开发要主要的点 泛型特性泛型的兼容性首先要强调的是，泛型是编译时才会检查合法性，编译后会直接擦除泛型信息。正由于这一点，所以在使用Eclipse编写源代码时，如果代码不合法，它会直接提示我们。Java编译器是向后兼容的，也就是低版本的源代码可以用高版本编译器进行编译。下面来看看那些兼容性代码。 引用和实例化都不包含泛型信息。 12345678910111213141516import java.util.ArrayList;import java.util.List;/** * @author xialei * @version 1.0 2016年6月28日下午9:03:44 */public class Compatibility &#123; public static void main(String[] args) &#123; // 下面编译通过 List list1 = new ArrayList(); list1.add("123"); list1.add(1); &#125;&#125; 上面的这段代码是可以通过编译的，这是JDK1.4之前的写法，所以可以验证JDK1.5之后的编译器是可以兼容JDK1.4之前的源代码的。不过，笔者在JDK1.8.x版本的编译器进行编译时，会抛出如下所示的警告信息。很显然，如果类被定义成泛型类，但是在实际使用时不使用泛型特性，这是不推荐的做法！ 12注: Compatibility.java使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。 引用使用泛型，实例化不使用泛型。 1234567891011121314151617import java.util.ArrayList;import java.util.List;/** * @author xialei * @version 1.0 2016年6月28日下午9:03:44 */public class Compatibility &#123; public static void main(String[] args) &#123; // 编译不通过 List&lt;String&gt; list2 = new ArrayList(); list2.add("123"); list2.add(1); // 这里出错 &#125;&#125; 上面的代码编译不通过，由于对引用使用了泛型，其中的所能容纳的对象必须为String 类型。这种写法实际上跟完整写法的作用一致，不过Eclipse仍然会警告。 引用不使用泛型，实例化使用泛型。 12345678910111213141516import java.util.ArrayList;import java.util.List;/** * @author xialei * @version 1.0 2016年6月28日下午9:03:44 */public class Compatibility &#123; public static void main(String[] args) &#123; // 编译通过 List list3 = new ArrayList&lt;String&gt;(); list3.add("123"); list3.add(1); &#125;&#125; 上面的这段代码可以编译通过，其效果与1（不使用泛型）完全一致。结合2、3可以知道，编译时只能做引用的类型检查，而无法检查引用所指向对象的实际类型。 泛型与继承在使用泛型时，引用的参数类型与实际对象的参数类型要保持一致（通配符除外），就算两个参数类型是继承关系也是不允许的。看看下面的2行代码，它们均不能通过编译。 12ArrayList&lt;String&gt; arrayList1 = new ArrayList&lt;Object&gt;(); //编译错误 ArrayList&lt;Object&gt; arrayList1 = new ArrayList&lt;String&gt;(); //编译错误 下面来探讨一下为什么不能这么做。 第1种情况，如果这种代码可以通过编译，那么调用get()方法返回的对象应该是String，但它实际上可以存放任意Object类型的对象，这样在调用类型转换指令时会抛出ClassCastException。这样可以不是那么明显，来看看下面的代码。arrayList1中实际存放的Object对象，所以在进行类型转换时会抛出异常。这原本就是泛型想要极力避免的问题，所以Java允许这种写法。 123ArrayList&lt;Object&gt; arrayList1 = new ArrayList&lt;Object&gt;(); arrayList1.add(new Object()); ArrayList&lt;String&gt; arrayList2 = arrayList1; //编译错误 第2种情况。虽然String类型的对象转换为Object不会有任何问题，但是这有什么意义呢？我们原本想要用String对象的方法，但最终将其赋予了一个Object类型的引用。如果需要使用String中的某些方法，必须将Object强制转换为String。这样不会抛出异常，但是却违背了泛型设计的初衷。 泛型与多态下面来考虑一下泛型中多态问题。普通类型的多态是通过继承并重写父类的方法来实现的，泛型也不例外，下面是一个泛型多态示例。 123456789101112131415161718192021/* * 个人主页：http://hinylover.space * * Creation Date: 2016年7月2日 下午7:50:35 */package demo.blog.java.generic;/** * @author xialei * @version 1.0 2016年7月2日下午7:50:35 */public class Father&lt;T&gt; &#123; public void set(T t) &#123; System.out.println("I am father, t=" + t); &#125; public T get() &#123; return null; &#125;&#125; 123456789101112131415161718192021222324252627282930/* * 个人主页：http://hinylover.space * * Creation Date: 2016年7月2日 下午7:50:57 */package demo.blog.java.generic;/** * @author xialei * @version 1.0 2016年7月2日下午7:50:57 */public class Son extends Father&lt;String&gt; &#123; @Override public void set(String t) &#123; super.set(t); System.out.println("I am son."); &#125; @Override public String get() &#123; return super.get(); &#125; public static void main(String[] args) &#123; Father&lt;String&gt; father = new Son(); father.set("hello world"); &#125;&#125; 上面定义了一个泛型父类和一个实际参数为String类型的子类，并“重写”了set(T)和get()方法。Son类中的@Override注解也清楚地显示这是一个重写方法，最终执行的结果如下，与想象中的结果完全一致。 12I am father, t=hello worldI am son. 真的这么简单么？虽然表面上（源代码层面）来看，泛型多态与普通类的多态并无二样，但是其内部的实时原理却大相径庭。 从上一篇文章可以知道，泛型类Father在编译后会擦除泛型信息，所有的泛型参数都会用Object类替代。实际上，Father编译后的字节码与下面的代码完全一致。 12345678910public class Father &#123; public void set(Object t) &#123; System.out.println("I am father, t=" + t); &#125; public Object get() &#123; return null; &#125;&#125; Son类的与最终会变为： 123456789101112131415161718public class Son extends Father &#123; @Override public void set(String t) &#123; super.set(t); System.out.println("I am son."); &#125; @Override public String get() &#123; return super.get(); &#125; public static void main(String[] args) &#123; Father father = new Son(); father.set("hello world"); &#125;&#125; Father和Son类的set()方法的参数类型不一样，所以，这并不是方法重写，而是方法重载！但是，如果是重载，那么Son类就应该会继承Father类的set(Object)方法，也就是Son会同时包含set(String)和set(Object)，下面来测试一下。 123Son son = new Son();son.set("test");son.set(new Object()); // 编译错误 当set一个Object对象时，编译无法通过。这就很奇怪了，感觉跟之前学到的知识是相悖的。我们原本想通过重写方法来实现多态，但由于泛型的类型擦除，却最终变成了重载，所以类型擦除与多态有了矛盾。那么Java是怎么解决这个问题的呢？还是从字节码中找答案吧。Son类最终的编译结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&#123; public demo.blog.java.generic.Son(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #8 // Method demo/blog/java/generic/Father."&lt;init&gt;":()V 4: return LineNumberTable: line 13: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Ldemo/blog/java/generic/Son; public void set(java.lang.String); // 我们重写的方法 descriptor: (Ljava/lang/String;)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: invokespecial #16 // Method demo/blog/java/generic/Father.set:(Ljava/lang/Object;)V 5: getstatic #19 // Field java/lang/System.out:Ljava/io/PrintStream; 8: ldc #25 // String I am son. 10: invokevirtual #27 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 13: return LineNumberTable: line 17: 0 line 18: 5 line 19: 13 LocalVariableTable: Start Length Slot Name Signature 0 14 0 this Ldemo/blog/java/generic/Son; 0 14 1 t Ljava/lang/String; public java.lang.String get(); // 我们重写的方法 descriptor: ()Ljava/lang/String; flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #36 // Method demo/blog/java/generic/Father.get:()Ljava/lang/Object; 4: checkcast #39 // class java/lang/String 7: areturn LineNumberTable: line 23: 0 LocalVariableTable: Start Length Slot Name Signature 0 8 0 this Ldemo/blog/java/generic/Son; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 0: new #1 // class demo/blog/java/generic/Son 3: dup 4: invokespecial #43 // Method "&lt;init&gt;":()V 7: astore_1 8: aload_1 9: ldc #44 // String hello world 11: invokevirtual #16 // Method demo/blog/java/generic/Father.set:(Ljava/lang/Object;)V 14: return LineNumberTable: line 27: 0 line 28: 8 line 29: 14 LocalVariableTable: Start Length Slot Name Signature 0 15 0 args [Ljava/lang/String; 8 7 1 father Ldemo/blog/java/generic/Father; LocalVariableTypeTable: Start Length Slot Name Signature 8 7 1 father Ldemo/blog/java/generic/Father&lt;Ljava/lang/String;&gt;; public java.lang.Object get(); // 编译器生成的方法 descriptor: ()Ljava/lang/Object; flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokevirtual #52 // Method get:()Ljava/lang/String; 4: areturn LineNumberTable: line 1: 0 LocalVariableTable: Start Length Slot Name Signature public void set(java.lang.Object); // 编译器生成的方法 descriptor: (Ljava/lang/Object;)V flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: checkcast #39 // class java/lang/String 5: invokevirtual #54 // Method set:(Ljava/lang/String;)V 8: return LineNumberTable: line 1: 0 LocalVariableTable: Start Length Slot Name Signature&#125; 编译结果有点长，为了方便，省去了无关的字节码。先注意到第77行和第90行，这里面多了一个Object get()方法和set(Object)方法，这两个方法在Son类源代码里面并不存在，这是编译器为了解决泛型的多态问题而自动生成的方法，称为“桥方法”。这两个方法的签名与Father类中的两个方法的签名完全一致，这才是真正的方法重写。也就是说，子类真正重写的我们看不到的桥方法，啊，多么痛的领悟！！！@Override注解只是假象，让人误以为他们真的是重写方法。 再看看set(Object)桥方法的实现细节，在第97行处先将Object对象强制转换为String对象，然后调用Son中的set(String)方法。饶了一个圈，最终才回到我们“重写”的方法。main方法中原本调用父类的set(Object)方法，由于子类通过桥方法重写了这个方法，所以最终的调用顺序是：set(Object) -&gt; set(String)。 这是脑海中必然会闪现出这么一个问题，既然调用的是set(Object)方法，那么可以在源代码中set一个Object对象么？下面来测试一下： 123Father&lt;String&gt; father = new Son();father.set("hello world");father.set(new Object()); // 编译错误 上面会出现编译错误，如果是在运行时环境中，这样是可以运行的，不过会出现ClassCastException异常。 与set(Object)桥方法的意义不同，Object get()并不仅仅解决泛型与重写的冲突，而更具有一般性。看看下面的代码，这是一个普通类的继承， 1234567891011/** * 普通类的继承。 * @author xialei * @version 1.0 2016年7月2日下午8:41:47 */public class GeneralFather &#123; public Object get() &#123; return null; &#125;&#125; 123456789101112/** * 普通类的继承。 * @author xialei * @version 1.0 2016年7月2日下午8:42:10 */public class GeneralSon extends GeneralFather &#123; @Override public String get() &#123; return ""; &#125;&#125; 子类的返回类型是父类的返回类型的子类，这是允许的，这种特性叫做Java返回值的协变性。而协变性的实现方法就是上面所述的桥方法。 这里还会有疑惑，set方法可以通过参数类型来确定调用的方法。但是，参数一样而返回值不一样是不能重载的。如果我们在源代码中通过编写String get()和Object get()方法是无法通过编译的。虽然，编译器无法通过编译，但是JVM是可以编写这两种方法的，它调用方法时，将返回值也作为方法签名的一部分。有种只许州官放火，不许百姓点灯的感觉。可以看到，JVM做了不少我们认为不合法的事情，所以如果不深入研究底层原理，有些问题根本解释不了。 泛型通配所谓泛型通配，是指在声明泛型类型的变量时，可以不必直接指定具体的泛型，而可以使用通配符号来代表一系列类型。通配符有2种： 无边界通配符，用&lt;?&gt;表示。 有边界通配符，用&lt;? extends Object&gt;或者&lt;? super extends Object&gt;来表示。（Object仅仅是一个示例） 为什么需要通配呢？先看下面的一个示例。 123456789101112131415161718192021222324252627282930313233343536/* * 个人主页：http://hinylover.space * * Creation Date: 2016年7月2日 下午9:18:04 */package demo.blog.java.generic;import java.util.ArrayList;import java.util.Collection;import java.util.List;/** * 解释为什么需要泛型通配。 * @author xialei * @version 1.0 2016年7月2日下午9:18:04 */public class WhyNeedWildcard &#123; /** * 创建一个能够打印所有集合对象中的元素的方法。 * @param collection */ public static void printCollection(Collection&lt;Object&gt; collection) &#123; for (Object object : collection) &#123; System.out.println(object); &#125; &#125; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("t1"); list.add("t2"); printCollection(list); // 编译不通过。The method printCollection(Collection&lt;Object&gt;) in the type WhyNeedWildcard is not applicable for the arguments (List&lt;String&gt;) &#125;&#125; 我们的本意是想创建一个能够打印所有集合对象中的元素的方法，但是上一篇文章已经说过了，泛型参数不支持继承，所以编译不通过。解决这个问题的办法就是使用通配符。 123456789101112131415161718192021222324252627282930313233343536/* * 个人主页：http://hinylover.space * * Creation Date: 2016年7月2日 下午9:18:04 */package demo.blog.java.generic;import java.util.ArrayList;import java.util.Collection;import java.util.List;/** * 解释为什么需要泛型通配。 * @author xialei * @version 1.0 2016年7月2日下午9:18:04 */public class WhyNeedWildcard &#123; /** * 创建一个能够打印所有集合对象中的元素的方法。 * @param collection */ public static void printCollection(Collection&lt;?&gt; collection) &#123; for (Object object : collection) &#123; System.out.println(object); &#125; &#125; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("t1"); list.add("t2"); printCollection(list); / 编译通过 &#125;&#125; 无边界无边界的通配符用&lt;?&gt;表示，上面的例子就是使用的无边界通配符。下面看看那些是合法的，哪些是不合法的。 123List&lt;?&gt; list = new ArrayList&lt;String&gt;(); // 合法List&lt;?&gt; list = new ArrayList&lt;?&gt;(); // 不合法List&lt;String&gt; list = new ArrayList&lt;?&gt;(); // 不合法 对于带有通配符的引用变量，是不能调用具有与泛型参数有关的方法的。 1234List&lt;?&gt; list = new ArrayList&lt;String&gt;();list.add(1); // 编译不通过list.get(0); // 编译通过int size = list.size(); // 由于size()方法中不含泛型参数，所以可以在通配符变量中调用 总结起来，无边界通配符主要用做引用，可以调用与泛型参数无关的方法，不能调用参数中包含泛型参数的方法。 有边界有边界的通配符会对引用的泛型类型进行限定，包括：上边界通配和下边界通配。 上边界通配，用&lt;? extends 类型&gt;表示。其语法为： 1List&lt;? extends 类型1&gt; x = new ArrayList&lt;类型2&gt;(); 其中，类型2就只能是类型1或者是类型1的子类。下面代码验证合法性。 12List&lt;? extends Number&gt; x = new ArrayList&lt;Integer&gt;(); //由于Integer是Number的子类，这是合法的List&lt;? extends Number&gt; x = new ArrayList&lt;String&gt;(); //由于String不是Number的子类，这是不合法的 下边界通配，用&lt;? super 类型&gt;表示。其语法为： 1List&lt;? super 类型1&gt; x = new ArrayList&lt;类型2&gt;(); 其中，类型2就只能是类型1或者是类型1的超类。下面代码有验证合法性。 12List&lt;? super Integer&gt; x = new ArrayList&lt;Number&gt;(); //由于Number是Integer的超类，这是合法的List&lt;? super Integer&gt; x = new ArrayList&lt;String&gt;(); //由于String不是Integer的超类，这是不合法的 那么到底什么时候使用下边界通配，什么时候使用上边界通配呢？首先考虑一下怎样才能保证不会发生运行时异常，这是泛型要解决的首要问题，通过前面的内容可以看到，任何可能导致类型转换异常的操作都无法编译通过。 上边界通配：可以保证存放的实际对象至多是上边界指定的类型，那么在读取对象时，我们总是可以放心地将对象赋予上边界类型的引用。 12345List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();list1.add(1);List&lt;? extends Number&gt; list2 = list1;Number a = list2.get(0); // 编译通过 下边界通配：可以保证存放的实际对象至少是下边界指定的类型，那么在存入对象时，我们总是可以放心地将上边界类型的对象存入泛型对象中。 123List&lt;? super Integer&gt; list3 = new ArrayList&lt;Number&gt;();list3.add(1);list3.add(2); 总结起来就是： 如果你想从一个数据类型里获取数据，使用 ? extends 通配符。 如果你想把对象写入一个数据结构里，使用 ? super 通配符。 如果你既想存，又想取，那就别用通配符。 这就是《Effective Java》书中所说的PECS法则（Producer Extends, Consumer Super），Collections工具类中的copy方法就完美地诠释了这个法则。 123public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123; ... &#125; 这个方法的作用是将src列表完整地拷贝到dest列表中。src是原始列表，我们需要读取其中的元素，所以它是生产者，需要使用extends通配；dest是目标列表，需要将读取出来的元素存入这个列表中，所以他是消费者，使用super通配。 泛型中的若干问题泛型与异常在异常问题上泛型是比较特殊的，主要表现在： 1、泛型类不能继承Throwable类，所以泛型类的对象既不能捕获也不能抛出。下面的代码是不合法的。 123public class Problem&lt;T&gt; extends Exception &#123; ... &#125; 假设上边的代码是合法的，那么我们可以catch住上面的定义的异常类。 1234567try &#123; &#125; catch (Problem&lt;String&gt; e1) &#123; &#125; catch (Problem&lt;Integer&gt; e1) &#123; &#125; 我们知道Problem类编译后会擦除泛型信息，相当于同时catch住了两个相同的异常（都是原始异常类Problem），这在Java中是不予许的。 2、不能在catch子句中使用泛型变量，譬如： 1234567public static &lt;T extends Throwable&gt; void doSomething(Class&lt;T&gt; t)&#123; try &#123; ... &#125; catch (T e) &#123; //编译错误 ... &#125;&#125; 假设上面合法，那么下面的情况呢？ 123456789public static &lt;T extends Throwable&gt; void doSomething(Class&lt;T&gt; t)&#123; try &#123; ... &#125; catch(T e) &#123; ... &#125; catch(IndexOutOfBounds e) &#123; ... &#125; &#125; 泛型在编译后会擦除泛型信息，所有的T都会用Throwable进行替换，如果上面是合法的，那么下面也是合法的。明显下面的catch顺序是不符合Java语法的。为了避免在运行时产生这种错误，所以Java干脆直接禁止了这种写法。 123456789public static &lt;T extends Throwable&gt; void doSomething(Class&lt;T&gt; t)&#123; try &#123; ... &#125; catch(Throwable e) &#123; ... &#125; catch(IndexOutOfBounds e) &#123; ... &#125; &#125; 泛型与基本类型泛型的实际类型必须是引用类型，而不能是基本类型，所以下面的代码都是不合法的。 123List&lt;int&gt; list = new ArrayList&lt;int&gt;(); // Syntax error, insert "Dimensions" to complete ReferenceTypeList&lt;byte&gt; list = new ArrayList&lt;byte&gt;(); // Syntax error, insert "Dimensions" to complete ReferenceType... 泛型与数组根据《Effective Java》书中所说，泛型与数组存在两个重要的不同点： 数组是协变的，而泛型不是。如果Son是Father的子类型，那么Son[]也是Father[]的子类型。而泛型则没有这种关系。 数组是可以具体化的，因此数组只有在运行时才知道其实际的元素类型。如果企图将String保存在Long数组中，会抛出ArrayStoreException异常。相比之下，泛型是通过编译时擦除泛型信息来实现的，因此，泛型只在编译时强化类型信息，并在运行时丢弃类型信息。 上面的不同点导致数组与泛型并不能很好的混合使用，下面的代码都是不合法的。 123new ArrayList&lt;String&gt;[2]; // Cannot create a generic array of ArrayList&lt;String&gt;new ArrayList&lt;T&gt;[2]; // Cannot create a generic array of ArrayList&lt;T&gt;new T[2]; // Cannot create a generic array of T 看看下面的代码。 1234List&lt;String&gt;[] array = new ArrayList&lt;String&gt;[];Object[] objectArray = array;objectArray[0] = 1;String c = array[0].get(0); 假设第1行代码是合法的，下面的3行代码都是没有问题的。objectArray数组的0号实际保存的是一个整型对象，而在第4行代码出却要转换为String类型，这会发生ClassCastException。异常的引入就是尽量消除这个运行时异常，所以第1行代码所示的数组是不合法的。 泛型实例化泛型变量是不能被实例化的，这个是笔者在实际开发过程多次遇到过的。 1Object c = new T(); // Cannot instantiate the type T 本意是想实例化一个类型为T的对象，但是这样是无法编译通过的。可以通过上一篇文章中的示例来实现： 123public &lt;T&gt; T getObject(Class&lt;T&gt; t) throws Exception &#123; return t.newInstance();&#125; 泛型与静态方法和静态类泛型类中的静态变量和静态方法和不可以使用泛型类所声明的泛型类型参数，下面的操作是不合法的。 1234567public class Test&lt;T&gt; &#123; public static T one; //编译错误 public static T show(T one)&#123; //编译错误 return null; &#125; &#125; 这是由于泛型的具体参数要在实例化是才能确定，而静态变量和静态方法无需实例化就可以调用。当对象都还没有创建时，就调用与泛型变量相关的方法，当然是错误的。不过，对于泛型方法，静态泛型方法是可以的，因为具体的泛型类型无需实例化就可以确定。 方法命名冲突下面来看看由于使用泛型而引起的方法命名冲突问题。 12345678public class Father&lt;T&gt; &#123; // 编译不通过，Name clash: The method equals(T) of type Father&lt;T&gt; has the same erasure as equals(Object) of type Object but does not override it public boolean equals(T obj) &#123; // TODO Auto-generated method stub return super.equals(obj); &#125;&#125; 我们的本意是想写一个与指定泛型类型对象判断相等性的方法，这个方法与Object的equals(Object)方法的含义本质上是不同的。Object的equals(Object)是判断相同类型的对象的相等，而我们定义的方法却不是这个含义。 以Father为例，看上去重载了Object的equals(Object)方法，因为我们定义的equals方法的参数是String类型的，也就是equals(String)。但是，由于Father在编译后会擦除泛型信息，所以equals(T)就被编译成了equals(Object)，这与Object的equals(Object)方法签名一模一样，这不就是覆盖么！我们并不想覆盖父类的方法，却在事实上覆盖了。如果上面的代码可以编译并运行，对于开发者来说就是一个大坑。唯一的办法就是改另外一个方法名罗。 其他泛型规范说明提及另一个原则“要支持擦除的转换，需要强行制一个类或者类型变量不能同时成为两个接口的子类，而这两个子类是同一接品的不同参数化。”下面的代码是非法的： 12class Calendar implements Comparable&lt;Calendar&gt;&#123; ... &#125; class GregorianCalendar extends Calendar implements Comparable&lt;GregorianCalendar&gt;&#123;...&#125; //ERROR GregorianCalendar会实现Comparable和Compable，是同一个接口的不同参数化实现，这是不允许的。 总结花了不少时间，将Java泛型中的核心内容整理完了，笔者收获颇丰，一些在平常开发中不解的问题也得到了解答。类型擦除是Java实现泛型的手段，也是被人说诟病的地方。文中的很多问题都是由类型擦除所引起的，也为开发者挖了不少“坑”。Java的进阶之旅还远没有结束，接下来还将继续学习Java。 参考文献： http://blog.csdn.net/lonelyroamer/article/details/7868820http://blog.csdn.net/lonelyroamer/article/details/7927212《Effective Java》 本文由xialei原创，，转载请说明出处http://hinylover.space/2016/07/03/relearn-java-generic-2/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新认识Java——泛型（基础、使用和实现原理）]]></title>
      <url>%2F2016%2F06%2F25%2Frelearn-java-generic-1%2F</url>
      <content type="text"><![CDATA[泛型是Java中重要知识点，是必须要深刻掌握的内容。由于泛型相关的内容比较多，基于单一知识原则，笔者打算将泛型部分分开成两部分书写。本文主要的内容如下： 泛型基础概念 泛型的分类、定义和使用 Java泛型的实现原理 泛型基础内容泛型是Java中一个非常重要的内容，对于Java进阶学习是必须要掌握的知识点。 解决的问题在开始介绍泛型的知识之前，先来了解一下泛型解决了什么问题，换句话说，为什么需要使用泛型。集合类是在开发过程中经常要用的类，下面是不使用泛型的代码示例。 1234567// 定义一个List，add()可以存放Object及其子类实例List list = new ArrayList();list.add(123); // 合法list.add("123"); // 合法// 我们在编译时无法知晓list到底存放的什么数据，于是在进行强制转换时发生异常int i = (Integer) list.get(1); // 抛出ClassCastException异常 上面的代码首先实例化一个ArrayList对象，它可以存放所有Object及其子类实例。分别add一个Integer类型对象和String类型对象，我们原本以为list中存放的全部是Integer类型对象，于是在使用get()方法获取对象后进行强制转换。从代码中可以看到，索引值为1的位置放置的String类型，很显然在进行强制转换时会抛出ClassCastException（类型转换异常）。由于这种异常只会发生在运行时，我们在开发时稍有不慎，就会直接掉到坑里，还很难排查出问题。 为什么会出现这种问题呢？ 集合本身无法对其存放的对象类型进行限定，可以涵盖Java中的所有类型。缺口太大，导致各种蛇、蚁、虫、鼠通通都可以进来。 由于我们要使用的实际存放类型的方法，所以不可避免地要进行类型转换。小对象转大对象很容易，大对象转小对象则有很大的风险，因为在编译时，我们无从得知对象真正的类型。 泛型就是为了解决这类问题而诞生的。 泛型中的基本概念泛型，即参数化类型，是在JDK1.5之后才开始引入的。所谓参数化类型，是指所操作的数据类型在定义是被指定为一个参数，然后在使用时传入具体的类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。还是以上一节的示例为例，下面是其泛型写法。 12345List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(123); // 合法list.add("123"); // 不合法，编译不通过int i = list.get(1); // 无需强制转换类型 在第1行代码中已经限定了List中仅可存放Integer类型对象，所以在第3行add一个String类型对象时，IDE会报错，并且无法编译通过。我们来看看JDK1.5之后的List接口定义如下： 123456public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; boolean add(E e); E get(int index);&#125; 上面的尖括号中的E就是泛型的类型参数（或者称之为形参），而在调用List类时，传入了Integer这个具体的类型参数（或者称为实参）。下面详细介绍一下泛型中一些基本术语（以List为例）： List称为泛型类型 List中的E称为类型变量或者类型参数 List称为参数化的类型 List中的Integer称为类型参数的实例或者实际类型参数 List中的念为typeof Integer List称为List的原始类型 泛型的定义和使用泛型的参数类型可以定义类、接口和方法中，分别称为泛型类、泛型接口和泛型方法。 泛型类的定义和使用一个泛型类（generic class）就是具有一个或多个类型变量的类。上面的例子中的List就是一个典型的泛型类。泛型类的定义结构类似下面的代码： 123456public class ClassName&lt;T1, T2&gt; &#123; // 可以任意多个类型变量 public void doSomething(T1 t1) &#123; System.out.println(t1); &#125;&#125; 注意，在Java编码规范中，类型变量通常使用较短的大写字母，并且最好与其作用相匹配。譬如：List中的变量使用E，对应单词Element，Map中的K，V变量对应单词Key和Value。当然这些都是约定性质的东西，其实类型变量的命名规则与Java中的普通变量命名规则是一致的。 下面的代码使用上面定义的泛型类，就是这么简单。 12ClassName&lt;String, String&gt; a = new ClassName&lt;String, String&gt;();a.doSomething("hello world"); 泛型接口的定义和使用接口本质上来说就是一种特殊的类，所以泛型接口的定义和使用与泛型类相差无几。下面的代码是泛型接口的定义和使用。 1234567891011public interface InterfaceName&lt;T1, T2&gt; &#123; // 可以任意多个类型变量 public void doSomething(T1 t1);&#125;public class ConcreteName&lt;T2&gt; implements InterfaceName&lt;String, T2&gt; &#123; public void doSomething(String t1) &#123; System.out.println(t1); &#125;&#125; 12InterfaceName&lt;String, String&gt; a = new ConcreteName&lt;String&gt;();a.doSomething("hello world"); 从上面的例子可以看出，如果实现一个泛型接口，可以在定义时直接传入具体的类型（如T1传入String），也可以继续传入一个类型，待使用时再确认具体的类型。 泛型方法的定义和使用泛型类和泛型接口的类型变量都是定义在类型级别，其作用域可覆盖成员变量和成员方法。泛型方法的类型参数定义在方法签名中，一个典型的泛型方法定义如下： 12345678910/** * 创建一个指定类型的无参构造的对象实例。 * @param &lt;T&gt; 待创建对象的类型。 * @param t 指定类型所对应的Class对象。 * @return 返回创建的对象。 * @throws Exception */public &lt;T&gt; T getObject(Class&lt;T&gt; t) throws Exception &#123; return t.newInstance();&#125; 上面的代码中表示这是一个泛型方法，T是仅作用于getObject方法上的类型变量。在调用这个方法时，传入具体的类型。 1String newStr = generic.getObject(String.class); 泛型变量的类型限定假定我们有个需求，需要编写一个获取两个对象中较大的对象的泛型方法，利用上面的泛型知识，编写出下面的代码。 1234567public &lt;T&gt; T getMax(T t1, T t2) &#123; if (t1.compareTo(t2) &gt; 1) &#123; // 编译错误 return t1; &#125; else &#123; return t2; &#125;&#125; 在上面的代码无法通过编译，由于我们都没有对类型变量对任何的约束限制，那么实际上这个类型可以是任意Object及其子类。那么在使用这个类型变量时，只能调用Object类中的方法。而Object本身就是Java中对顶层的类，没有实现Comparable接口，所以无法调用compareTo方法来比较对象的大小。这时候可以通过限定类型变量来达到目的。 1234567public &lt;T extends Comparable&lt;T&gt;&gt; T getMax(T t1, T t2) &#123; if (t1.compareTo(t2) &gt; 1) &#123; return t1; &#125; else &#123; return t2; &#125;&#125; 注意到上面的代码使用extends关键字限定了类型变量T必须继承自Comparable，于是变量t1和t2就可以使用Comparable接口中的compareTo方法了。 不管是泛型类、泛型接口还是泛型方法，都可以进行类型限定。类型限定的特点如下： 不管该限定是类还是接口，统一都使用extends关键字。 使用&amp;符号进行多个限定，那么传入的具体类型必须同时是这些类型的子类。 123public &lt;T extends Serializable&amp;Cloneable&amp;Comparable&gt; T getMax(T t1, T t2) &#123; ...&#125; 由于Java中不支持多继承，所以不存在一个同时继承两个以上的类的类。所以，在泛型的限定中，&amp;连接的类型最多只能有一个类，而接口数量则没有限制。同时，如果同时限定类和接口，则必须将类写在最前面。 123public &lt;T extends Object&amp;Serializable&amp;Cloneable&amp;Comparable&gt; T getMax(T t1, T t2) &#123; // 合法 ...&#125; 123public &lt;T extends Object&amp;ArrayList&gt; T getMax(T t1, T t2) &#123; // 同时限定两个类，不合法 ...&#125; 123public &lt;T extends Serializable&amp;Cloneable&amp;Comparable&amp;Object&gt; T getMax(T t1, T t2) &#123; // 将类写在最后面，不合法 ...&#125; 泛型的实现原理前面介绍了泛型的基础知识以及使用方法，下面将更加深入地介绍泛型的底层原理。 Java中的泛型是伪泛型泛型思想最早在C++语言的模板（Templates）中产生，Java后来也借用了这种思想。虽然思想一致，但是他们存在着本质性的不同。C++中的模板是真正意义上的泛型，在编译时就将不同模板类型参数编译成对应不同的目标代码，ClassName和ClassName是两种不同的类型，这种泛型被称为真正泛型。这种泛型实现方式，会导致类型膨胀，因为要为不同具体参数生成不同的类。 Java中ClassName和ClassName虽然在源代码中属于不同的类，但是编译后的字节码中，他们都被替换成原始类型（ClassName），而两者的原始类型的一样的，所以在运行时环境中，ClassName和ClassName就是同一个类。Java中的泛型是一种特殊的语法糖，通过类型擦除实现（后面介绍），这种泛型称为伪泛型。由于Java中有这么一个障眼法，如果没有进行深入研究，就会在产生莫名其妙的问题。值得一提的是，不少大牛对Java的泛型的实现方式很不满意。 类型擦除Java中的泛型是通过类型擦除来实现的。所谓类型擦除，是指通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。 下面通过两个例子来证明在编译时确实发生了类型擦除。 例1分别创建实际类型为String和Integer的ArrayList对象，通过getClass()方法获取两个实例的类，最后判断这个实例的类是相等的，证明两个实例共享同一个类。 123456789// 声明一个具体类型为String的ArrayListArrayList&lt;String&gt; arrayList1 = new ArrayList&lt;String&gt;(); arrayList1.add("abc"); // 声明一个具体类型为Integer的ArrayListArrayList&lt;Integer&gt; arrayList2 = new ArrayList&lt;Integer&gt;(); arrayList2.add(123); System.out.println(arrayList1.getClass() == arrayList2.getClass()); // 结果为true 例2创建一个只能存储Integer的ArrayList对象，在add一个整型数值后，利用反射调用add(Object o)add一个asd字符串，此时运行代码不会报错，运行结果会打印出1和asd两个值。这时再里利用反射调用add(Integer o)方法，运行会抛出codeNoSuchMethodException异常。这充分证明了在编译后，擦除了Integer这个泛型信息，只保留了原始类型。12345678ArrayList&lt;Integer&gt; arrayList3 = new ArrayList&lt;Integer&gt;();arrayList3.add(1);arrayList3.getClass().getMethod("add", Object.class).invoke(arrayList3, "asd");for (int i = 0; i &lt; arrayList3.size(); i++) &#123; System.out.println(arrayList3.get(i)); // 输出1，asd&#125;arrayList3.getClass().getMethod("add", Integer.class).invoke(arrayList3, 2); // NoSuchMethodException：java.util.ArrayList.add(java.lang.Integer) 自动类型转换上一节上说到了类型擦除，Java编译器会擦除掉泛型信息。那么调用ArrayList的get()最终返回的必然会是一个Object对象，但是我们在源代码并没有写过Object转成Integer的代码，为什么就能“直接”将取出来的对象赋予一个Integer类型的变量呢（如下面的代码第12行）？ 1234567891011121314import java.util.List;import java.util.ArrayList;/** * 泛型中的类型转换测试。 */public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;(); a.add(1); Integer ai = a.get(0); &#125;&#125; 实际上，Java的泛型除了类型擦除之外，还会自动生成checkcast指令进行强制类型转换。上面的代码中的main方法编译后所对应的字节码如下。 1234567891011121314151617181920212223242526public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: new #2 // class java/util/ArrayList 3: dup 4: invokespecial #3 // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: iconst_1 10: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 13: invokeinterface #5, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z 18: pop 19: aload_1 20: iconst_0 21: invokeinterface #6, 2 // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object; 26: checkcast #7 // class java/lang/Integer 29: astore_2 30: return LineNumberTable: line 7: 0 line 8: 8 line 9: 19 line 10: 30&#125; 看到第18行代码就是将Object类型的对象强制转换为Integer的指令。我们完全可以将上面的代码转换为下面的代码，它所实现的效果跟上面的泛型是一模一样的。既然泛型也需要进行强制转换，所以泛型并不会提供运行时效率，不过可以大大降低编程时的出错概率。 12345public static void main(String[] args) &#123; List a = new ArrayList(); a.add(1); Integer ai = (Integer)a.get(0);&#125; 小结本文介绍了泛型的基础知识，定义和使用以及泛型实现原理，涉及到的知识比较多，本文仅仅是开始，更多内容将在下一篇文章中做详细介绍。 参考文献： http://blog.csdn.net/lonelyroamer/article/details/7864531http://blog.csdn.net/lonelyroamer/article/details/7868820 本文由xialei原创，转载请说明出处http://hinylover.space/2016/06/25/relearn-java-generic-1/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新认识Java——基本类型和包装类]]></title>
      <url>%2F2016%2F06%2F16%2Frelearn-java-base-type-and-wrapper%2F</url>
      <content type="text"><![CDATA[Java一种静态编程语言，所有变量和表达式是在编译时就确定的。同时，Java又是一种强类型语言，所有的变量和表达式都有具体的类型，并且每种类型是严格定义的。类型限制了变量可以hold什么样的值，表达式最终会产生什么样的值，可以进行哪些操作。在Java中共有8中基本类型数据，同时每种基本类型又有对应的包装类。本文将介绍Java中的基本数据类型及其包装类，主要内容如下： 介绍Java中的基本类型及其大小 基本类型之间的转换 包装类 基本类型Java共有8种基本数据类型，它们分别如下表所示： 基本数据类型 类型 byte 数值型 short 数值型 int 数值型 long 数值型 float 数值型 double 数值型 char 字符型 boolean 布尔型 占用空间大小在介绍基本类型时，先将一个概念——字面量值（literal）。所谓字面量值，就是指表面上的值，譬如5、200等值是整型字面量值，如果想要long型字面量值，在整型字面量值后面加上l或者L（推荐L）。整型字面量值可以由多种不同的表达方式，如16进制值（以0X或者0x开头）、10进制、8进制值（以0开头）和2进制值（以0B或者0b开头，JDK1.7以上版本才有）。 byte、short、int、long类型变量都可以赋予整型字面量值，譬如byte a = 10、short b = 0x45都是合法的赋值操作。Java编译器在编译是会检查字面量值所表示的数字大小是否处于变量类型的合法范围内，如果不在，则无法通过编译。如果多种数值类型的数据进行数学运算时，计算结果的类型是其中这些数值中最高等级或者其更高等级类型。 基本类型的占用空间大小 byte（字节）用无符号的8位表示，它的取值范围是[-2^7, 2^7-1]。它是最小的整型类型，通常用于网络传输、文件或者其他I/O数据流。默认值是0。 short（短整型）用有符号的16位表示，它的取值范围是[-2^15, 2^15-1]。从日常的观察来看，short类型可能是最不常用的类型了。完全可以用int来替代它，因为我们通常不需要过多地担心内存容量问题。默认值是0。 int（整型）用有符号的32位表示，它的取值范围是[-2^31, 2^31-1]，计算机中用存放的是整型数值的二进制补码。默认值是0。 long（长整型）用有符号的64位表示，它的取值范围是[-2^63, 2^63-1]。它的字面量表示以l或者L结束，如 long a = 45454L。默认值是0L。 float（单精度浮点型）用32位表示，遵循IEEE 754规范。如果数值精度要求不高时，可以使用这种类型。float类型字面量值通常以f或者F结束。由于整型可以自动转换为float类型，所以，我们也可以将整型字面量值直接赋予float类型变量。默认值是0F。 double（双精度浮点型）用64位表示，遵循IEEE 754规范。它能表示比float更高精度的数值。double是Java基本类型中能达到的最高精度，如果还不能满足要求，可以使用Java中的BigDecimal类。默认值是0.0。 char（字符）用无符号的16位表示，它的取值范围是[0, 2^16-1]。Java中使用Unicode字符集来表示字符，Unicode将人类语言的所有已知字符映射成16位数字，所以Java中的char是16位的。默认值是\u00000。 boolean（ 布尔型）只要true和false两个字面量值，可用于逻辑判断。boolean只能表示1位的信息量，但是它的大小并没有精确地定义。 基本类型的运算和相互转换基本类型运算boolean类型数据可以进行逻辑运算（&amp;&amp;、||、！），其他的基本类型都可以进行数值计算（+、-、*、/、%等）。逻辑运算比较简单易懂，完全与逻辑数学的规则一致。而数值运算涉及到运算后的结果的类型问题，稍微比较复杂一点。一般来说，运算最终结果的类型与表达式中的最大（占用空间最大）的类型。 1234long l = 1 + 2L; // 与1L的类型一致int i = 1 + 2L; // 编译不通过float f = 1 + 2 + 1.2f; // 与1.2f的类型一致double d = 1 + 2 + 1.2; // 与1.2的类型一致 如果两种相同的类型的数据进行运算，按理来说，运算结果应该还是那个类型。但事实上，byte、char、short等类型是满足这个结论的。 123456789101112131415// 编译不通过，编辑器报：Type mismatch: cannot convert from int to byte 。byte s1 = 1;byte s2 = 1;byte s = s1 + s2;// 编译不通过，编辑器报：Type mismatch: cannot convert from int to char 。char s1 = 1;char s2 = 1;char s = s1 + s2;// 编译不通过，编辑器报：Type mismatch: cannot convert from int to short 。short s1 = 1;short s2 = 1;short s = s1 + s2; 从字面上来看，1+1=2绝对没有超过这个类型的范围。下面的例子都可以编译通过， 123byte s1 = 1 + 1;char s2 = 1 + 1;short s3 = 1 + 1; 这是因为Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型。这种方式所得到结果是否超过了对应类型所表示的范围只能在运行时才能确定，在编译时是无法知晓的。而编译器会直接将byte s1 = 1 + 1编译成byte s1 = 2，这个表达式在编译器就可以确定是合法表达式，故可以通过编译。可以通过字节码来进行佐证。 1short s = 1 + 1; 上面伪代码所对应的字节码如下，iconst_2表示直接生成常量，然后赋值给s变量。 12345Code: stack=1, locals=2, args_size=1 0: iconst_2 1: istore_1 2: return 类型转换Java中除了boolean类型之外，其他7中类型相互之间可以进行转换。转换分为自动转换和强制转换。对于自动转换（隐式），无需任何操作，而强制类型转换需要显式转换，即使用转换操作符（type）。7种类型按照其占用空间大小进行排序： byte &lt;（short=char）&lt; int &lt; long &lt; float &lt; double 类型转换的总则是：小可直接转大、大转小会失去精度。这句话的意思是较小的类型直接转换成较大的类型，没有任何印象；而较大的类型也可以转换为较小的类型，但是会失去精度。他们之间的转换都不会抛出任何运行时异常。小转大是Java帮我们自动进行转换的，与正常的赋值操作完全一样；大转小需要进行强制转换操作，其语法是target-type var =（target-type） value。 12345678// 自动转换long l = 10;double d = 10;float = 10;// 强制转换int a = (int) 1.0;char c = (char) a; 值得注意是，大转小是一个很不安全的动作，可能导致莫名其妙的错误。譬如在下面的代码中，1111111111111L强转成int类型后，其值（-1285418553）与转换前的值相差巨大。这是由于在进行强制转换时，在二进制层面上直接截断，导致结果“面目全非”。 包装类Java中每一种基本类型都会对应一个唯一的包装类，基本类型与其包装类都可以通过包装类中的静态或者成员方法进行转换。每种基本类型及其包装类的对应关系如下，值得注意的是，所有的包装类都是final修饰的，也就是它们都是无法被继承和重写的。 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 包装类与基本类型的转换从源代码的角度来看，基础类型和包装类型都可以通过赋值语法赋值给对立的变量类型，如下面的代码所示。 12Integer a = 1;int a = new Integer(1); 这种语法是可以通过编译的。但是，Java作为一种强类型的语言，对象直接赋值给引用类型变量，而基础数据只能赋值给基本类型变量，这个是毫无异议的。那么基本类型和包装类型为什么可以直接相互赋值呢？这其实是Java中的一种“语法糖”。“语法糖”是指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会（来自百度百科）。换句话说，这其实是一种障眼法，那么实际上是怎么样的呢？下面是Integer a = 1;语句编译的字节码。 1230: iconst_11: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;4: astore_1 首先，生成一个常量1，然后调用Integer.valueOf(int)方法返回Integer对象，最后将对象的地址（引用）赋值给变量a。Integer a = 1;其实相当于Integer a = Integer.valueOf(1);。 其他的包装类都是类似的，下表是所有包装类中的类型转换方法。 包装类 包装类转基本类型 基本类型转包装类 Byte Byte.valueOf(byte) byteInstance.byteValue() Short Short.valueOf(short) shortInstance.shortValue() Integer Integer.valueOf(int) integerInstance.intValue() Long Long.valueOf(long) longInstance.longValue() Float Float.valueOf(float) floatInstance.floatValue() Double Double.valueOf(double) doubleInstance.doubleValue() Character Character.valueOf(char) charInstance.charValue() boolean Boolean.valueOf(booleann) booleanInstance.booleanValue() “神奇”的包装类如果不了解包装类中的一些机制，我们有时会碰到一些莫名其妙的问题，丈二和尚——摸不着头脑。 “莫名其妙”的NullPointException在笔者开发经历中，碰到过不少因为请求参数或者接口定义字段设置为int（或者其他基本类型）而导致NullPointException。代码大致地运行步骤如下所示，当然不会跟这个完全一样。 123Integer a = null;...int b = a; // 抛出NullPointException 上面的代码可以编译通过，但是会抛出空指针异常（NullPointException）。前面已经说过了，int b = a实际上是int b = a.intValue()，由于a的引用值为null，在空对象上调用方法就会抛出NullPointException。 两个包装类引用相等性在Java中，“==”符号判断的内存地址所对应的值得相等性，具体来说，基本类型判断值是否相等，引用类型判断其指向的地址是否相等。看看下面的代码，两种类似的代码逻辑，但是得到截然不用的结果。 1234567Integer a1 = 1;Integer a2 = 1;System.out.println(a1 == a2); // trueInteger b1 = 222;Integer b2 = 222;System.out.println(b1 == b2); // false 这个必须从源代码中才能找到答案。Integer类中的valueOf()方法的源代码如下： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127] return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象 return new Integer(i); // 如果不在，则创建一个新的Integer对象&#125; 由于1属于[-128, 127]集合范围内，所以valueOf()每次都会取出同一个Integer对象，故第一个“==”判断结果为true；而222不属于[-128, 127]集合范围内，所以valueOf()每次都会创建一个新的Integer对象，由于两个新创建的对象的地址不一样，故第一个“==”判断结果为false。 本文由xialei原创，转载请说明出处http://hinylover.space/2016/06/16/relearn-java-base-type-and-wrapper/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新认识Java语言——异常（Exception）]]></title>
      <url>%2F2016%2F06%2F05%2Frelearn-java-exception%2F</url>
      <content type="text"><![CDATA[异常，是Java中非常常用的功能，它可以简化代码，并且增强代码的安全性。本文将介绍一些异常高级知识，也是学习Java一来的一次总结。包括以下内内容： 异常的基础知识 异常特点 异常误用 如何正确地使用异常 异常的实现原理 关于异常异常机制，是指程序不正常时的处理方式。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。 异常的一般性语法为： 1234567try &#123; // 有可能抛出异常的代码&#125; catch (Exception e) &#123; // 异常处理&#125; finally &#123; // 无论是否捕获到异常都会执行的程序&#125; Java异常体系Java异常中的体系结构如下图所示。 Throwable类是整个Java异常体系的超类，都有的异常类都是派生自这个类。包含Error和Exception两个直接子类。 Error表示程序在运行期间出现了十分严重、不可恢复的错误，在这种情况下应用程序只能中止运行，例如JAVA虚拟机出现错误。在程序中不用捕获Error类型的异常。一般情况下，在程序中也不应该抛出Error类型的异常。 Exception是应用层面上最顶层的异常类，包含RuntimeException（运行时异常）和 Checked Exception（受检异常）。 RuntimeException是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。一般来说，RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。常见的RuntimeException有NullPointException、ClassCastException、IllegalArgumentException、IndexOutOfBoundException等。 Checked Exception是相对于Unchecked Exception而言的，Java中并没有一个名为Checked Exception的类。它是在编程中使用最多的Exception，所有继承自Exception并且不是RuntimeException的异常都是Checked Exception。JAVA 语言规定必须对checked Exception作处理，编译器会对此作检查，要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。常用的Checked Exception有IOException、ClassNotFoundException等。 异常的特点通用特点JVM捕获并处理未被应用程序捕获的异常无论是受检异常（Checked Exception）还是运行时异常（Runtime Exception），如果异常没有被应用程序捕获，那么最终这个异常会交由JVM来进行处理，会明显出现下面两个结果： 当前线程会停止运行，异常触发点后面的代码将得不到运行。 异常栈信息会通过标准错误流输出。 12345678910111213141516171819202122/** * 应用程序没有处理抛出的异常时，会交由JVM来处理这个异常。结果是： * 1. 当前线程会停止运行，异常触发点后面的代码将得不到运行。 * 2. 异常栈信息会通过标准错误流输出。 * * @author xialei * @version 1.0 2016年5月18日下午9:53:54 */public class UncatchedException &#123; public static void main(String[] args) throws Exception &#123; throwException(); System.out.println("这一行不会被打印出来"); &#125; public static void throwException() throws Exception &#123; int i = 0; if (i == 0) &#123; throw new Exception(); &#125; &#125;&#125; 异常catch有顺序性在catch异常时，如果有多个异常，那么是会有顺序要求的。子类型必须要在父类型之前进行catch，catch与分支逻辑是一致，如果父类型先被catch，那么后被catch的分支根本得不到运行机会。 12345678910111213141516171819202122232425/* * 个人主页：http://hinylover.space * * Creation Date: 2016年4月7日 下午2:29:42 */package demo.blog.java.exception;/** * 在catch异常时，如果有多个异常，那么是会有顺序要求的。子类型必须要在父类型之前进行catch， * catch与分支逻辑是一致，如果父类型先被catch，那么后被catch的分支根本得不到运行机会。 * * @author xialei * @version 1.0 2016年5月18日下午10:00:40 */public class ExceptionCatchOrder &#123; public void wrongCatchOrder() &#123; try &#123; Integer i = null; int j = i; &#125; catch (Exception e) &#123; &#125; catch (NullPointerException e) &#123; // 编译不通过，eclipse提示“Unreachable catch block for NullPointerException. It is already handled by the catch block for Exception” &#125; &#125;&#125; 异常被吃掉如果在finally中返回值，那么在程序中抛出的异常信息将会被吞噬掉。这是一个非常值得注意的问题，因为异常信息是非常重要的，在出现问题时，我们通常凭它来查找问题。如果编码不小心而导致异常被吞噬，排查起来是相当困难的，这将是一个大隐患。 1234567891011121314151617181920212223242526/* * 个人主页：http://hinylover.space * * Creation Date: 2016年4月7日 下午2:29:42 */package demo.blog.java.exception;/** * 如果在finally中返回值，那么在程序中抛出的异常信息将会被吞噬掉。 * @author xialei * @version 1.0 2016年5月18日下午10:08:43 */public class FinallySwallowException &#123; public static void main(String[] args) throws Exception &#123; System.out.println(swallowException()); // 打印出2，而不是打印出异常栈 &#125; public static int swallowException() throws Exception &#123; try &#123; throw new Exception(); &#125; finally &#123; return 2; &#125; &#125;&#125; 重写Exception的fillInStackTrace()方法使用自定义异常时，可以重写fillInStackTrace()方法来控制Exception的异常栈信息。默认情况下，在程序抛出异常时，最终会通过调用private native Throwable fillInStackTrace(int dummy)这个本地方法来获取当前线程的堆栈信息，这是一个非常耗时的操作。如果我们仅仅需要用到异常的传播性质，而不关系异常的堆栈信息，那么完全可以通过重写fillInStackTrace()方法来实现。 123456789101112131415161718192021222324252627282930313233343536/* * 个人主页：http://hinylover.space * * Creation Date: 2016年4月7日 下午2:29:42 */package demo.blog.java.exception;/** * 重写Exception的fillInStackTrace()方法 * * @author xialei * @version 1.0 2016年5月18日下午10:18:57 */public class MyException extends Exception &#123; public MyException(String message) &#123; super(message); &#125; /* * 重写fillInStackTrace方法会使得这个自定义的异常不会收集线程的整个异常栈信息，会大大 * 提高减少异常开销。 */ @Override public synchronized Throwable fillInStackTrace() &#123; return this; &#125; public static void main(String[] args) &#123; try &#123; throw new MyException("由于MyException重写了fillInStackTrace方法，那么它不会收集线程运行栈信息。"); &#125; catch (MyException e) &#123; e.printStackTrace(); // 在控制台的打印结果为：demo.blog.java.exception.MyException: 由于MyException重写了fillInStackTrace方法，那么它不会收集线程运行栈信息。 &#125; &#125;&#125; 受检异常（checked exception）必须处理或者向上抛出我们必须要对底层抛出来的受检异常进行处理，处理方式有try…catch…或者向上抛出（throws），否则程序无法通过编译。 1234567891011121314151617package demo.blog.java.exception;/** * 必须对底层抛出的异常进行处理 * @author xialei * @version 1.0 2016年5月18日下午10:42:53 */public class CheckedException &#123; public static void main(String[] args) &#123; throwException(); // 编译不通过，必须对底层抛出的异常进行处理 &#125; public static void throwException() throws Exception &#123; throw new Exception(); &#125;&#125; 不能捕获未被抛出的受检异常如果我们试图去捕获一个未被抛出的受检异常，程序将无法通过编译（Exception除外）。 123456789101112131415161718192021222324/* * 个人主页：http://hinylover.space * * Creation Date: 2016年5月18日 下午10:45:32 */package demo.blog.java.exception;import java.io.IOException;/** * 不能捕获一个没有被抛出的受检异常（Exception除外） * @author xialei * @version 1.0 2016年5月18日下午10:45:32 */public class CantCatchUnthrowedException &#123; public void cantCatchUnthrowedException() &#123; try &#123; int i = 0; &#125; catch (IOException e) &#123; // 编译不通过，eclipse提示：Unreachable catch block for IOException. This exception is never thrown from the try statement body e.printStackTrace(); &#125; &#125;&#125; 运行时异常（runtime exception）运行时异常（runtime exception）与受检异常（checked exception）的最大区别是不强制对抛出的异常进行处理。所有的运行时异常都继承自RuntimeException这个类，别问为什么，Java是这么规定的。与受检异常类似的例子，如果抛出的是运行时异常，就算不捕获这个异常，程序也可以编译通过。 12345678910111213141516171819/* * 个人主页：http://hinylover.space * * Creation Date: 2016年5月18日 下午11:02:57 */package demo.blog.java.exception;/** * 编译通过 * @author xialei * @version 1.0 2016年5月18日下午11:02:57 */public class MyRuntimeException &#123; public void myRuntimeException() &#123; throw new RuntimeException(); // 可以正常编译 &#125;&#125; 异常的使用用受检异常还是运行时异常？在使用异常时，笔者经常为使用何种异常而犯难，在实际使用过程中总结了一些小经验。 大概率发生时使用运行时异常从概率上来说，如果这个异常发生的频率非常高，那么因为使用运行时异常，最典型的就是NullPointException。Java中调用每个对象的方法时，都有可能会发生NullPointException。如果这是一个受检异常，那么在每次调用对象方法要么try {} catch {}，那么使用throws关键字向上抛出。无论哪种方式，代码无疑都会是非常丑陋的，那画面太“美”不敢看。如果代码里充斥着各种异常处理块，可读性将会大打折扣。 异常无法恢复时使用运行时异常当异常发生时，如果开发者无法从异常状态恢复到正常状态，那么这种异常应该是运行时异常。如果使用受检异常，这除了加重开发者的负担之外，别无它用。当在调用其他方法时，如果方法抛出受检异常，那么笔者就会比较紧张。因为这意味着需要停止业务逻辑开发，然后开始思考如何处理这该死的异常。运行时异常通常是由于开发者编程不当所引起的，譬如空指针异常、除零异常等。如果开发者在开发过程中小心谨慎，考虑周全，就可能避免这种异常的发生。 可恢复时优先使用受检异常如果我们能够从异常中恢复到正常状态，那么应该优先使用受检异常。为什么是优先而不是一定呢？因为从原理上来说，使用运行时异常也可以恢复到正常状态，而且使用运行时异常的代码无疑会比较干净整洁。而使用受检异常，明确地说明了调用方式时可能发生异常情况，强制开发者去处理这些异常情况常常会增强代码的健壮性。受检异常通常是由外部环境所引起的，譬如IOException等。 使用受检异常做流程控制从Java语义上来说，应该是当程序层面真正发生异常状况时才应该使用异常（Exception），《Effect Java》一书中也建议只有真正的异常情况才使用异常。但我们有时也会利用异常来达到业务流程控制的目的。这样做主要有下面的好处： 简化代码逻辑。我们无需为多分枝业务流程编写各种if…else…语句来处理不同的情况。相反地，我们只需处理正常的业务流程即可，异常流程只需要通过异常向上抛出去即可，至于谁去处理这些异常，则不需要我们过多地关心。 可读性增强。如果一段代码中充斥着分枝逻辑，那么整个代码的可读性会非常差。在阅读代码时，很难理清楚代码的主干。说到底，主干代码才是我们重点关注的。如果使用异常进行流程控制，主干代码就清晰地显示在面前，两个字：舒服！ 尽量集中处理异常在各种有关代码重构的书本中，都会提到一个核心原则：一个方法应该仅做一件事情。如果一个方法中，既包含业务逻辑，又包含异常处理程序，那么实际上这个方法就做了两件事情。如果异常上层可以处理，那么就不应该在下层处理。在上层进行处理的好处是，可以对异常进行统一地处理。而至于将异常处理程序分散到代码的各个地方，导致维护起来十分困难。在进行异常处理时，应该优先考虑使用AOP（面向切面编程）技术，这样降低了核心业务逻辑与异常处理的耦合性。 自定义异常体系在应用系统中应该要建立自己的异常体系，这样便于统一处理系统中出现的异常。笔者在开发过程中，通常会建立类似下图所示的系统体系。越靠近底层，越使用更加底层的、具体的异常。如果是其他系统中的异常（譬如Java自身的异常），也应该将其转化为自定义体系中的对应异常。 异常误用e.printTrace()处理所有异常。使用e.printTrace()来粗暴地处理所有异常是新手经常犯的毛病，笔者在初学时也是这么干的。为什么会出现这种情况呢？因为如果未处理的受检异常，代码将编译不通过，IDE（如eclipse）中会无情地打上各种红叉叉。这是IDE可以帮我们处理的情况，于是按照IDE的提示，try{}catch{}这段代码，其默认的异常处理就是调用e.printTrace()方法。初学者只顾着代码顺利通过编译，而完全没有考虑这样做存在的风险。这样做的风险如下： 错失正确的处理方法。相当一部分受检异常通过正确地处理是可以恢复正常，简单粗暴地使用e.printTrace()将错失恢复机会。 “丢失”异常信息。printTrace()方法是Throwable类中的一个方法，它的作用是将异常栈信息打印到标准错误流中。如果Web项目，会将异常信息打印到容器的日志文件中；如果是普通项目，通常会将标准输出和标准错误重定向到dev/null（空设备）中。无论是何种情况，都有可能导致异常信息“丢失”（web容器中的日志其实不代表丢失了，但是我们通常不会利用容器级别的日志排错），给排错带来很大的麻烦。 全部使用运行时异常为了“偷懒”，无论什么情况都使用运行时异常，这样就可以不用费劲处理异常了，轻轻松松。但是，现在没事不代表以后不出事，这无疑为代码埋下了隐患。如果在调用一个方法时，该方法并没有显示地抛出异常，也没有在javadoc中强调，我们就不会知道调用这段代码可能发生的异常情况，那些可能出现的异常情况对我们来说是透明的。 总是catch Exception对象在捕获和处理异常时，不管3721，一股脑地catch Exception对象。没错，这样就可以一次性处理所有异常情况。但是，所有地异常都使用相同的处理程序真的对吗？在这样做之前应该先要打个大大的问号。这样做的后果是我们会无形中忽略那些重要的异常。 正确使用异常 正确地处理异常。针对不用的异常采取合适的、正确的异常处理方式，不要遇到任何异常都printTrace()或者打印一个日志。 catch时指定具体的异常。不要一股脑地catch Exception，具体的异常应该单独catch住，越具体的异常越早catch。 涉及到资源时，需要finally。如果涉及到资源的关闭时，应该将关闭资源的代码写在finally代码块内。 最小化try{ } catch{ }范围。try的范围应该尽量小，最好就是try住抛出异常的那个方法即可。 异常的实现原理（字节码级别）从字节码层面上来分析一下Java异常的实现原理，编写如下所示的源代码，使用javac命令进行编译，然后使用javap命令查看编译后的字节码细节内容。 123456789101112131415public class ExceptionClassCode &#123; public int demo() &#123; int x; try &#123; x = 1; return x; &#125; catch (Exception e) &#123; x = 2; return x; &#125; finally &#123; x = 3 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233public int demo(); descriptor: ()I flags: ACC_PUBLIC Code: stack=1, locals=5, args_size=1 0: iconst_1 // 生成整数1 1: istore_1 // 将生成的整数1赋予第1号局部变量（x=1） 2: iload_1 // 将x(=1)的值入栈 3: istore_2 // 将栈顶的值（=1）赋予第2号变量（returnValue） 4: iconst_3 // 生成整数3 5: istore_1 // x=3 6: iload_2 // returnValue=当前栈顶值（=1） 7: ireturn // 返回returnValue（=1） 8: astore_2 // 将Exception对象引用值赋予第2号局部变量 9: iconst_2 // 生成整数2 10: istore_1 // x=2 11: iload_1 // x(=2)压入栈顶 12: istore_3 // 将栈顶的值（=2）赋予第3号变量（returnValue） 13: iconst_3 // 生成整数3 14: istore_1 // x=3 15: iload_3 // returnValue(=2)压入栈顶 16: ireturn // 返回returnValue（=2） 17: astore 4 // 将异常信息保存到第4号局部变量 19: iconst_3 // 生成整数3 20: istore_1 // x=3 21: aload 4 // 将异常引用值压入栈 23: athrow // 抛出栈顶所引用的异常 Exception table: from to target type 0 4 8 Class java/lang/Exception # 如果0~4行字节码（try代码块）中出现Exception及其子类异常，则执行第8行（catch代码行） 0 4 17 any # 无论0~4行字节码（try代码块）是否抛出异常，都执行第17行（finally代码行） 8 13 17 any # 无论8~13行字节码（catch代码块）是否抛出异常，都执行第17行（finally代码行） 17 19 17 any 看到字节码中有一个Exception table（异常表）区域，这个就是与异常相关的字节码内容。它表示在from到to所指示的字节码行中，如果抛出type所对应的异常（及其子类），那么就跳到target指定的字节码行开始执行。 本文由xialei原创，转载请说明出处http://hinylover.space/2016/06/05/relearn-java-exception/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新认识Java系列文章索引]]></title>
      <url>%2F2016%2F05%2F10%2Frelearn-java-index%2F</url>
      <content type="text"><![CDATA[换了新工作，比之前忙了好多（虽然更多的是瞎JB忙），没有之前的精力学习和写文章了。每天回到家昏昏沉沉的，啥都不想干。这样的日子真是令人反感，还是希望每天能够更充实一下，每天还有时间学学自己想学的东西。不过这些看起来都是借口，如果有学习欲望，每天或多或少都能够挤出时间来的。接下来还是要延续写文章的习惯！ 不知不觉工作已经2年有余，算上在学校的时间，接触Java已经差不多5年。现在回过头来看一看，自己还是在曲折中不断进步的。相比刚开始的时候，对Java语言的理解更加深刻。是时候重新认识一下Java了，接下来会针对Java中的核心内容和难点做一个梳理和总结。 下面是文章索引，笔者会实时更新文章链接。 重新认识Java——异常（Exception）重新认识Java——基本类型和包装类重新认识Java——泛型（基础、使用和实现原理）重新认识Java——泛型（通配、特性和注意点）重新认识Java——字符串（String）重新认识Java——容器体系（Collection）重新认识Java——线程（Thread）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用springmvc+mybatis创建Web应用（二）—— 数据库、配置和测试]]></title>
      <url>%2F2016%2F04%2F11%2Fspringmvc-mybatis-createproject-demo-2%2F</url>
      <content type="text"><![CDATA[引言上一篇文章简单地介绍了如何从零开始构建一个Spring MVC应用，如果我们仅仅需要做一些静态页面或者数据不变化的Web应用，那么其实这样就足够了。这当然是不现实的，我们的页面中的数据需要不断地变化，不同的用户登录进来之后应用只能看到属于自己的数据，诸如此类的需求告诉我们原本的代码框架是不够的。 对于一个功能相对齐整的Web应用，除了上一篇文章中介绍的代码框架，还需要： 连接和操作数据库 配置文件 单元测试（虽然可以省略，但还是建议保留） 接下来的内容就介绍上面所列举的内容，以期能创建一个比较完整的Web应用框架。 使用Mybatis操作数据库上一篇文章中已经简单地介绍过了Mybatis中的基本概念，下面直接进入实战环节。由于要依赖第三方的工具包，pom.xml文件中需要新添加依赖如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!-- database --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- test --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;version&gt;0.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path-assert&lt;/artifactId&gt; &lt;version&gt;0.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- test end --&gt; JDBC连接池连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用。 在项目中使用连接池是非常有必要，主要有以下好处： 减少连接创建时间 简化的编程模式 受控的资源使用 Java中有以下常用的开源连接池： C3P0 DBCP Proxool 在本文中将使用C3P0来作为数据库连接池组件，并且用Spring来管理C3P0。为了使用Spring来管理应用中的所有组件，我们先在Web.xml文件中配置下面的代码，使得Spring的上下文（context）文件能够随着应用一块启动。 123456789&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 插个题外话，注意Spring的上下文配置的路径为：classpath:applicationContext.xml。在笔者刚开始学习Java的很长一段时间里，都不太明白什么是classpath，以致于常常取不到资源文件。 classpath表示一个绝对路径，但不是一个固定值。它是编译完毕后存放xxx.class文件的最顶层目录所对应的路径。譬如使用Maven编译之后通常（如果没有手动修改Maven配置）会将编译后的class文件放置在target\classes目录下，于是classpath表示的绝对路径为：工程根路径\target\classes\。所以，本文中的Spring的上下文配置文件的绝对路径为：工程根路径\target\classes\applicationContext.xml 在src/main/resources资源文件夹下创建一个applicationContext.xml文件，该文件中的代码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"&gt; &lt;!-- 配置数据连接池（C3P0） --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test?characterEncoding=utf8" /&gt; &lt;property name="user" value="test" /&gt; &lt;!-- 数据库用户名 --&gt; &lt;property name="password" value="test" /&gt; &lt;!-- 数据库密码 --&gt; &lt;property name="maxPoolSize" value="10" /&gt; &lt;property name="minPoolSize" value="1" /&gt; &lt;property name="initialPoolSize" value="2" /&gt; &lt;property name="maxIdleTime" value="20" /&gt; &lt;property name="acquireIncrement" value="3" /&gt; &lt;property name="idleConnectionTestPeriod" value="60" /&gt; &lt;property name="unreturnedConnectionTimeout" value="190" /&gt; &lt;property name="checkoutTimeout" value="20000" /&gt; &lt;property name="acquireRetryAttempts" value="30" /&gt; &lt;/bean&gt; &lt;!-- 配置数据库事务 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; 数据库表Mybatis的主要功能是将Mapper配置映射成对应的sql语句并执行。在介绍Mybatis的配置之前，先创建一个简单的数据表作为数据示例。 数据表User的结构如下： 字段 类型 索引 字段含义 username varchar(50) 主键 用户名 password varchar(50) 密码 role int 用户角色 笔者使用的是mysql数据库，sql语句如下： 1234567891011CREATE DATABASE test; USE test;CREATE TABLE `test`.`User`( `username` VARCHAR(50) COMMENT '用户名', `password` VARCHAR(50) COMMENT '密码', `role` INT COMMENT '角色') ENGINE=INNODB CHARSET=utf8 COLLATE=utf8_general_ci;INSERT INTO User VALUES("test", "test", 1); # 插入一条记录 Mybatis配置在src/main/resources资源文件夹中创建一个spring-mybatis.xml文件，这个取名可以任意，只不过是方便记忆而已。 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!-- mybatis SqlSessionFactory配置 --&gt; &lt;bean id="sessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="mapperLocations" value="classpath:/mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- Mapper 扫描配置 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="sqlSessionFactoryBeanName" value="sessionFactory" /&gt; &lt;property name="basePackage" value="demo.dao" /&gt; &lt;/bean&gt;&lt;/beans&gt; 在【mybatis SqlSessionFactory配置】配置项中，指定了mybatis的Mapper文件所在的位置（classpath:/mapper/*.xml）。于是，在src/main/resources资源文件夹创建一个mapper子目录，将所有的Mapper文件放置在这个文件夹下。 在applicationContext.xml文件中引入spring-mybatis.xml，使其加入spring的管理容器中。 1&lt;import resource="classpath:spring-mybatis.xml"/&gt; Dao接口和Mapper配置首先创建一个demo.model包，在这个包下创建一个名为User的类。这个类的字段与上面设计的数据表里面的字段是一一对应的。 123456789101112131415161718192021222324252627282930313233343536373839package demo.model;/** * 数据模型，与数据库表里面的字段对应。 * @author xialei * */public class User &#123; private String username; private String password; private Integer role; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getRole() &#123; return role; &#125; public void setRole(Integer role) &#123; this.role = role; &#125;&#125; 接着创建一个demo.dao包，在这个包下创建一个名为UserMapper的类。这个类的作用是定义一系列数据操作方法。 12345678910111213141516package demo.dao;import org.apache.ibatis.annotations.Param;import demo.model.User;public interface UserMapper &#123; /** * 访问数据库，检查用户名和密码输入是否正确。 * @param username * @param password * @return */ public User check(@Param("username") String username, @Param("password") String password);&#125; 最后创建UserMapper所对应的Mapper文件（UserMapper.xml），mybatis会根据这个文件生成这个接口的一个实现类。 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;!-- demo.dao.UserMapper与UserMapper定义路径一致 --&gt;&lt;mapper namespace="demo.dao.UserMapper" &gt; &lt;!-- demo.model.User与User的定义路径一致，下面是Java对象与数据库字段的映射关系。 --&gt; &lt;resultMap id="BaseResultMap" type="demo.model.User" &gt; &lt;id column="username" property="username" jdbcType="VARCHAR" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;result column="role" property="role" jdbcType="TINYINT" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; username, password, role &lt;/sql&gt; &lt;!-- id必须与UserMapper中定义的方法名一致。 --&gt; &lt;select id="check" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from user where username = #&#123;username,jdbcType=VARCHAR&#125; and password = #&#123;password,jdbcType=VARCHAR&#125; &lt;/select&gt;&lt;/mapper&gt; 示例为了测试整个框架是否已经打好，我们写一个测试页面来测试一下，就用最常用的登录功能来验证。 首先，创建一个User控制器(UserController.java)。 12345678910111213141516171819202122232425262728293031323334package demo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import demo.dao.UserMapper;import demo.model.User;@Controllerpublic class UserController &#123; @Autowired private UserMapper userMapper; @RequestMapping("/login") public String login() &#123; return "login"; &#125; @RequestMapping("/dologin") public ModelAndView doLogin(String username, String password) &#123; User user = this.userMapper.check(username, password); if (user == null) &#123; return new ModelAndView("error"); &#125; else &#123; ModelAndView modelAndView = new ModelAndView("success"); modelAndView.addObject("username", username); return modelAndView; &#125; &#125;&#125; 然后，创建对应的jsp页面来显示结果。 登录页面：login.jsp，文件路径为：src/main/webapp/WEB-INF/jsp/login.jsp 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;$&#123;pageContext.servletContext.contextPath&#125;/dologin&quot; method=&quot;post&quot;&gt; 用户名：&lt;input name=&quot;username&quot; type=&quot;text&quot; &gt; 密码：&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登录成功页面：success.jsp，文件路径为：src/main/webapp/WEB-INF/jsp/success.jsp 1234567891011&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;登录成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 登录成功！您的用户名为：&lt;%=request.getParameter(&quot;username&quot;)%&gt;&lt;/body&gt;&lt;/html&gt; 登录失败页面：error.jsp，文件路径为：src/main/webapp/WEB-INF/jsp/error.jsp 1234567891011&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;登录失败&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 登录失败，用户名或密码错误。&lt;/body&gt;&lt;/html&gt; 使用Jetty启动应用，在浏览器中输入http://localhost:8080/login进入登录界面。如果输入正确的用户名和密码（test/test），则跳入success.jsp对应的页面，输入其他信息，则跳入error.jsp对应的页面。 使用配置文件通常系统中存在常量（数据库连接URL、用户名、密码等），这些常量如果直接嵌入到Java代码中，则一旦代码编译完毕后就无法更改，如需更改则只能在源代码中改完后重新编译。当然，如果像上面一样，写在诸如applicationContext.xml的xml文件中也是可以的。但是如果这样的文件很多，找起来就会比较困难。 比较推荐的方法是将这些常量集中写到一个常量配置文件中。Java中默认的配置文件后缀是.properties，下面就将常量移入配置文件中。 首先，在applicationContext.xml中加入下面的代码，表示用配置文件中的值来替换掉applicationContext.xml中的变量引用表达式。 1&lt;context:property-placeholder location="classpath:config.properties"/&gt; 在src/main/resources文件夹中创建config.properties配置文件，加入如下代码： 1234567891011121314# ------------------ Data source ----------------dataSource.pool.driverClass=com.mysql.jdbc.DriverdataSource.pool.jdbcUrl=jdbc:mysql://localhost:3306/test?characterEncoding=utf8dataSource.pool.user=testdataSource.pool.password=testdataSource.pool.maxPoolSize=10dataSource.pool.minPoolSize=1dataSource.pool.initialPoolSize=2dataSource.pool.maxIdleTime=20dataSource.pool.acquireIncrement=3dataSource.pool.idleConnectionTestPeriod=60dataSource.pool.unreturnedConnectionTimeout=190dataSource.pool.checkoutTimeout=20000dataSource.pool.acquireRetryAttempts=30 同时，修改applicationContext.xml文件代码，使用EL表达式来引用这些配置项的值。 1234567891011121314151617&lt;!-- 配置数据连接池（C3P0） --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;property name="driverClass" value="$&#123;dataSource.pool.driverClass&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;dataSource.pool.jdbcUrl&#125;" /&gt; &lt;property name="user" value="$&#123;dataSource.pool.user&#125;" /&gt; &lt;property name="password" value="$&#123;dataSource.pool.password&#125;" /&gt; &lt;property name="maxPoolSize" value="$&#123;dataSource.pool.maxPoolSize&#125;" /&gt; &lt;property name="minPoolSize" value="$&#123;dataSource.pool.minPoolSize&#125;" /&gt; &lt;property name="initialPoolSize" value="$&#123;dataSource.pool.initialPoolSize&#125;" /&gt; &lt;property name="maxIdleTime" value="$&#123;dataSource.pool.maxIdleTime&#125;" /&gt; &lt;property name="acquireIncrement" value="$&#123;dataSource.pool.acquireIncrement&#125;" /&gt; &lt;property name="idleConnectionTestPeriod" value="$&#123;dataSource.pool.idleConnectionTestPeriod&#125;" /&gt; &lt;property name="unreturnedConnectionTimeout" value="$&#123;dataSource.pool.unreturnedConnectionTimeout&#125;" /&gt; &lt;property name="checkoutTimeout" value="$&#123;dataSource.pool.checkoutTimeout&#125;" /&gt; &lt;property name="acquireRetryAttempts" value="$&#123;dataSource.pool.acquireRetryAttempts&#125;" /&gt;&lt;/bean&gt; 这样在spring容器启动时，会用配置文件中的值替换掉对应的表达式。 单元测试在Java体系中，JUnit无疑是最强大的单元测试工具，这里就不介绍JUnit的使用了。Spring管理的应用中，依赖关系比较复杂，而且有时会有隐蔽性，单纯的JUnit恐怕很难进行测试。下文介绍专门用于Spring应用单元测试的spring-test组件，以及用于Web应用测试的mock组件的简单使用。 简单的测试Maven中，通常将所有的测试用例写在src/test/java源文件夹下。下面的代码测试UserMapper这个类，这仅仅是一个样例，介绍如何使用spring-test进行测试而已，测试用例并具有可参考性。 12345678910111213141516171819202122232425262728293031package demo.test.dao;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import demo.dao.UserMapper;import demo.model.User;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;"classpath:applicationContext.xml"&#125;)public class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void testDoLoginWrong() &#123; User user = this.userMapper.check("eroor", "error"); Assert.assertNull(user); &#125; @Test public void testDoLoginRight() &#123; User user = this.userMapper.check("test", "test"); Assert.assertNotNull(user); &#125;&#125; web测试进行web测试时，需要模拟HTTP请求。使用spring-test无需将Web应用部署到服务器就可以进行测试，非常方便实用。下面是一个示例，更多的关于spring-test的知识可以看这篇博文。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package demo.test.controller;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultHandlers;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.servlet.config.annotation.EnableWebMvc;/** * * @author xialei * */@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration("src/main/webapp")@ContextConfiguration(locations = &#123;"classpath:applicationContext.xml", "file:src/main/webapp/WEB-INF/dispatch-servlet.xml"&#125;)@EnableWebMvcpublic class UserControllerTest &#123; @Autowired private WebApplicationContext wac; protected MockMvc mockMvc; @Before public void setUp() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125; @Test public void testDoLogin() throws Exception &#123; MvcResult mvcResult = mockMvc.perform(MockMvcRequestBuilders.post("/dologin").param("username", "test").param("password", "test")) .andDo(MockMvcResultHandlers.print()).andReturn(); String viewName = mvcResult.getModelAndView().getViewName(); Assert.assertEquals("success", viewName); String value = (String)mvcResult.getModelAndView().getModelMap().get("username"); Assert.assertEquals("test", value); &#125; @Test public void testDoLoginIllegalInput() throws Exception &#123; MvcResult mvcResult = mockMvc.perform(MockMvcRequestBuilders.post("/dologin").param("username", "error").param("password", "error")) .andDo(MockMvcResultHandlers.print()).andReturn(); String viewName = mvcResult.getModelAndView().getViewName(); Assert.assertEquals("error", viewName); &#125;&#125; 总结关于使用SpringMVC+Mybatis来创建一个Web应用系列已经写完了。文章从无到有地创建了一个Web应用，知识点讲得不太细，旨在梳理创建整个应用过程中涉及到的概念、组件。阅读本系列文章可以了解到创建一个基于SpringMVC+Mybatis的Web应用是如何一步一步地搭建起来的，虽然示例比较简单，基本停留在Demo级别，但还是比较完整的。在今后创建类似Web应用时，可以直接拿来做代码骨架。 使用springmvc+mybatis创建Web应用（一）—— 相关概念，工具，搭建Web应用 Github地址：https://github.com/xialei199023/springmvc-mybati-webapp 本文由xialei原创，转载请说明出处http://hinylover.space/2016/04/11/springmvc-mybatis-createproject-demo-2/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用apidocJs快速生成在线文档]]></title>
      <url>%2F2016%2F03%2F31%2Fcreate-online-document-use-apidoc%2F</url>
      <content type="text"><![CDATA[apidoc是一个轻量级的在线REST接口文档生成系统，支持多种主流语言，包括Java、C、C#、PHP和Javascript等。使用者仅需要按照要求书写相关注释，就可以生成可读性好、界面美观的在线接口文档。本文主要包含以下内容： 介绍apidoc的基本概念 安装、使用和简单配置 一些特殊参数的含义及其使用 介绍一些使用经验 前言apidoc能做什么apidoc是一个轻量级的在线REST接口文档生成系统，可以根据其特定的规则的代码注释来生成静态网页。首先看下它生成的文档界面和风格。 支持apidoc支持多种主流的编码语言，包括Java、C、C#、PHP和Javascript。一般情况下，语言会有多种注释方法，例如就Java中有普通风格的多行注释和Javadoc风格的注释。apidoc并不支持所有的注释，譬如Java仅中支持Javadoc风格的注释。首先要说明的是，apidoc并不具备语义识别能力，它不会发现代码中是否有BUG，它仅仅通过文件后缀来判断语言类型。下面是一些不同语言注释示例： Java、Javascript、PHP 12345678910/** * @api &#123;get&#125; /user/:id Request User information * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; id Users unique ID. * * @apiSuccess &#123;String&#125; firstname Firstname of the User. * @apiSuccess &#123;String&#125; lastname Lastname of the User. */ Python 12345678910"""@api &#123;get&#125; /user/:id Request User information@apiName GetUser@apiGroup User@apiParam &#123;Number&#125; id Users unique ID.@apiSuccess &#123;String&#125; firstname Firstname of the User.@apiSuccess &#123;String&#125; lastname Lastname of the User.""" 安装apidoc是基于nodeJs平台，在安装apidoc之前，需要先安装nodeJs。关于nodeJs的安装，一搜一大把，不过为了文章的完整性，还是首先介绍一下Windows平台下nodeJs的安装。 nodeJs安装首先，去node.js官网上下载最新的安装包，请下载自己对应系统的安装包。譬如笔者的操作系统是64位Windows操作系统，就下载下图所示的node安装包。 下载完毕后，按照一般的软件安装步骤安装即可。由于笔者的计算机已经安装过了，在这里就不过细演示了。 按理来说，按照安装步骤安装完毕后，node环境也已经配置好了，现在来验证一下node是否已正确安装配置。 首先，打开Window Shell窗口。使用win+R快捷键打开运行窗口，在文本框中输入cmd并回车打开Windows Shell。 然后，在控制台输入node命令进入node控制台。 最后，运行一个Hello World程序。在node控制台中输入console.info(“hello world”);，如果输出如下图所示的结果，则表示node安装配置成功。 除了node之外，npm（node package manager，node安装包管理器）也是很重要的，可以通过它来便捷地下载和安装node应用。在Windows Shell中输入npm命令，如果出现如下图所示的信息，则表示npm也正确安装完毕。 apidoc安装apidoc可以利用npm来快速安装。 1、进入Windows Shell，输入mpm install apidoc -g进行apidoc的安装，如下图。 等待一定时间（根据自身的网速）的下载和安装之后，如果出现下图所示的信息，则表示apidoc安装成功。 2、在Windows Shell中输入apidoc -v命令，如果出现如下图所示的界面，则表示apidoc已安装成功。 初步使用下面通过一些简单的demo来介绍如何利用apidoc生成一份在线接口文档。 命令行在正式开始之前，先介绍一下apidoc中的重要命令和参数。apidoc的命令格式如下： 1apidoc 参数 一些重要的参数如下表所示： 参数 描述 -f 选择要解析的文件，支持正则表达式。-f参数可以使用多次，多个表达式可以对应不同的-f。如：apidoc -f “.\.js$” -f “.\.ts$” -i 选择源代码所在的位置。如：apidoc -i myapp/ -o 选择生成的目标文件所在的位置。如：apidoc -o apidoc/ -t 为生成文件选择模板，可以创建和使用自定义的模板。（笔者注：目前为止，笔者还没有使用过这个参数） -h 跟绝大多数命令一样，这个参数可以打印出帮助文档 1apidoc -i src/ -o apidoc/ # 可以通过搜索src目录中的文件快速的生成文档文件，并将这些文件放在apidoc目录下。 1apidoc -h # 显示帮助信息 使用apidoc一个典型的文件目录结果如下图所示。 其中： apidoc.json：apidoc的项目级配置文件，它必须位于整个工程目录顶层。 Demo1.java：用于演示的demo源文件，它可以位于整个工程目录的顶层目录及其子目录下。apidoc会搜索整个工程目录选择所有可能的源文件。 apidoc.json和Demo1.java中包含的代码分别如下： 1234567&#123; "name": "demo", "version": "1.0.0", "description": "这是一个简单的apidoc的demo", "title": "demo", "url" : "https://api.github.com/v1"&#125; 12345678910/** * @api &#123;get&#125; /user/:id Request User information * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; id Users unique ID. * * @apiSuccess &#123;String&#125; firstname Firstname of the User. * @apiSuccess &#123;String&#125; lastname Lastname of the User. */ 下面通过这个demo来介绍如何生成文档文件。 首先，在Windows Shell中进入apidoc工程目录的上层目录。例如笔者的apidoc的工程位于E:\workspaces\sublime\apidoc路径下。在这个目录中创建名为src的工程目录，将apidoc.json和Demo1.java文件置于src目录下。 然后，在Windows Shell中输入apidoc -i src/ -o apidoc/命令，如果出现如下图所示的Done结果，则表明文档已经生成，位于同级目录的apidoc（与-o apidoc对应）目录下。 最后，打开apidoc目录，可以看到如下图所示的静态Web文件。双击index.html就可以在浏览器中打开生成在线接口文档网站。 这样我们就成功地生成了一份在线接口文档了，接下来就只要部署到任意Web容器（Apache、Tomcat等）就可以将接口文档对外发布了，So easy！ 配置apidoc.json文件是项目级的配置文件，接下来简单地介绍一下其中常用的配置项。 配置名 描述 name 工程名。如果该字段不存在，则apidoc会尝试通过package.json（apidoc顶层配置文件）来生成 version 工程文档的版本号。如果该字段不存在，则apidoc会尝试通过package.json（apidoc顶层配置文件）来生成 description 工程详细描述。如果该字段不存在，则apidoc会尝试通过package.json（apidoc顶层配置文件）来生成 title 文档标题，显示在文档界面的最上方 url 整个api url的前缀，接下来的所有接口url都会加上这个前缀 sampleUrl api示例的url前缀。如果设置了这个值，则界面中显示请求表单，可以用于测试接口 header title 文档头（header）的连接锚点名 filename 文档头所使用的文件 footer title 文档尾（footer）的连接锚点名 filename 文档尾所使用的文件 order 接口的排列顺序list，如果不指定，则由apidoc自行确定 一个比较完整的配置文件如下： 12345678910111213141516171819202122&#123; "name": "demo", "version": "1.0.0", "description": "这是一个简单的apidoc的demo", "title": "demo", "url": "https://api.github.com/v1", "sampleUrl": "https://api.github.com/v1/test", "header": &#123; "title": "header", "filename": "header.md" &#125;, "footer": &#123; "title": "footer", "filename": "footer.md" &#125;, "order": [ "Error", "Define", "PostTitleAndError", "PostError" ]&#125; 更多的配置项请参考apidoc官方文档站点。 Paramsapidoc中最核心的东西就是参数（params）的书写，本节介绍apidoc中一些重要的params。 @api@api定义一个特定的接口。如果一个注释块既不包含@apiDefine又没有包含@api参数，则apidoc会直接忽略这个注释块。这个参数在界面上表示一个接口区域块如下: @api的书写格式为： 1@api &#123;method&#125; path [title] 注意，[xxx]表示一个可选的参数，下同。 下表介绍了@api中的参数含义。 参数 描述 method 请求的HTTP方法名，包括DELETE, GET, POST, PUT，更多方法详见http-learn-url path 请求的url path（不包括前缀） title 接口名，用于接口索引。这个配置项会显示在导航菜单中。 更多的配置项请参考apidoc官方文档站点。 @apiDefine@apiDefine表示定义一个变量，该变量可以指代任意值（字符串、参数块），这个参数并且写在独立的代码块中。可以使用@apiUse来使用其定义的变量。 @apiDefine的书写格式为： 1@apiDefine name [title] [description] 下表介绍了@apiDefine中的参数含义。 参数 描述 name 值或者块的名字，可以看做就是变量名 title 标题，一般用于@apiParam (name)参数，显示请求参数所在组的名称 description 该变量的描述。 下面的代码定义一个错误块，然后在接口定义中引用使用这个错误块。多个不同接口可以引用同样的@apiDefine块，这也变成语言的变量功能一直。可以消除重复代码。 123456789/** * @apiDefine MyError * @apiError UserNotFound The &lt;code&gt;id&lt;/code&gt; of the User was not found. *//** * @api &#123;get&#125; /user/:id * @apiUse MyError */ @apiDescription用于@api代码块中，用于详尽地描述接口的功能。 @apiDescription的书写格式为： 1@apiDescription text text就是具体的描述内容，可以直接使用Markdown语法，这极大地丰富了其表现形式。 @apiGroup表示接口所属的组，最直接的体现就是在侧边导航中将接口分在对用的组中。 @apiGroup的书写格式为： 1@apiGroup name name表示组名，可以是任意字符串。值得注意的是，name不支持中文，一旦输入中文，apidoc就会忽略这些中文字符。如果需要在界面中显示中文接口组名，只需要使用@apiDefine定义一个中文字符串，然后name用变量名替换即可。 123456789/** * @apiDefine group 测试 *//** * @api &#123;get&#125; /user/:id Request User information * @apiName GetUser * @apiGroup group */ @apiName表示接口的名字，应该在每个@api块中使用。可以生成一个Web锚点，快速定位接口位置。可以看到锚点（url的#后面的字符串）通常由groupName-apiName构成。 @apiName的书写格式为： 1@apiName name @apiUse表示引用一个@apiDefine定义的值或块，相当于直接替换变量的值。 @apiUse的书写格式为： 1@apiUse name name是一个已定义的@apiDefine中的name，如果输入的name不存在，则会抛出类似下面的异常信息。 123456&#123; File: &apos;src\\Demo1.java&apos;, Block: 4, Element: &apos;@apiUse&apos;, Groupname: &apos;test&apos;, Definition: &apos;@apiUse group&apos;, Example: &apos;@apiDefine MyValidGroup Some title\n@apiUse MyValidGroup&apos; &#125; 下面是一个示例： 123456789/** * @apiDefine test * @apiParam &#123;Number&#125; id Users unique ID. *//** * @apiUse test * @apiParam &#123;Number&#125; name name. */ @apiParam表示一个请求参数。 @apiParam的书写格式为： 1@apiParam [(group)] [&#123;type&#125;] [field=defaultValue] [description] 下表介绍了@apiParam中的参数含义。 参数 描述 (group) 参数所在的组，可以使用@apiDefine定义的值 {type} 参数的类型。例如 {Boolean}, {Number}, {String}, {Object}, {String[]} (array of strings), .. field 请求参数名。 [field] 表示这个参数是个可选参数，非必传参数。 =defaultValue 表示这个参数的默认值。 description 这个请求参数的描述，支持Markdown语法。 下面是一个简单的示例： 12345678910/** * @api &#123;get&#125; /user/:id * @apiParam &#123;Number&#125; id Users unique ID. *//** * @api &#123;post&#125; /user/ * @apiParam &#123;String&#125; [firstname] 用户名（非必填）. * @apiParam &#123;String&#125; lastname 用户姓（必填）. */ @apiSuccess表示请求成功时的一个返回字段。 @apiSuccess的书写格式为： 1@apiSuccess [(group)] [&#123;type&#125;] field [description] @apiSuccess的参数含义与@apiParam一致，这里就不再做说明了。 @apiError表示请求失败时的一个返回字段。 @apiError的书写格式为： 1@apiError [(group)] [&#123;type&#125;] field [description] 与apiSuccess的参数含义完全一致。 @apiParamExample表示一个请求范例。 @apiParamExample的书写格式为： 1@apiParamExample [&#123;type&#125;] [title] example 参数 描述 {type} 表示请求数据的格式 title 显示在界面上的示例标题 example 示例实体 下面是一个简单的示例： 1234567/** * @api &#123;get&#125; /user/:id * @apiParamExample &#123;json&#125; Request-Example: * &#123; * "id": 4711 * &#125; */ @apiSuccessExample表示一个响应范例。其书写格式和参数含义与@apiParamExample完全一样。 @apiSampleRequest表示一个接口测试块，可以根据定义的请求参数来生成一个表单，用来进行接口测试。 @apiSampleRequest的书写格式为： 1@apiSampleRequest url url可以与配置文件（apidoc.json）中的sampleUrl以及@api定义的path连接成一个完整的测试url。例如： 12345/** * @api &#123;get&#125; /user/:id * @apiParam &#123;Number&#125; id Users unique ID. * @apiSampleRequest /test */ 生成的界面截图如下： 一些实际经验下面介绍一下在实际使用过程发现的东西。 绝大部分地方可使用Markdown语法在几乎所有的描述类字段处都可以使用符合Markdown语法的文本，可以使得文档形式更加美观。 1234567/** * @api &#123;get&#125; /user/:id * @apiParam &#123;String&#125; rule * * - 规则1：不能使用小数 * - 规则2：不能相加 */ 对象类型的参数如果请求的参数是一个对象，那此时因为如果书写呢？比如需要Post一个Person对象，Person中包括name、age字段，那么可以这样书写。 1234567/** * @api &#123;post&#125; /user * @apiName obj * @apiParam &#123;Object&#125; person * @apiParam &#123;String&#125; person.name 姓名 * @apiParam &#123;Integer&#125; person.age 年龄 */ 从下图中可以看到name和age字段的前面有些缩进，而且字段显示名为name和age。 本文由xialei原创，转载请说明出处http://hinylover.space/2016/03/31/create-online-document-use-apidoc/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用springmvc+mybatis创建Web应用（一）—— 相关概念，工具，搭建Web应用]]></title>
      <url>%2F2016%2F03%2F23%2Fspringmvc-mybatis-createproject-demo-1%2F</url>
      <content type="text"><![CDATA[前言springmvc和mybatis是当前最流行的创建java web项目的框架组合，有了它们就能创建一个简单的Web项目。笔者将相关内容以系列文的形式撰写，本文将详细演示如何搭建起一个最简单的web应用骨架。 由于涉及到的内容比较多，深究起来细节非常多且繁琐，所以有些内容并不会讲得很细，仅仅对过程进行大致描述。按理来说，要理解本系列文章需要一定的基础，包括： spring基础 J2EE基础 数据库基础 有了上述基础，看起来就会比较轻松。如果基础计较薄弱，也可以直接从本文中的内容开始着手，遇到不清楚的内容再查资料，这样就可以有的放矢。 本文的主要内容包括： 相关的知识点概要介绍； 安装eclipse、maven等相关开发工具 使用springMVC搭建一个简单的Web应用。 相关知识介绍在正式介绍创建步骤之前，先简单的介绍了其中会涉及到的一些软件和工具。 Maven：基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。其最重要的功能是自动下载所需的依赖包，让开发者再也不用为下载依赖包而发愁了！ Jetty：一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。它可以嵌入在应用程序内部，作为web容器对外提供服务。 Springmvc：Spring框架中的一个子模块，提供了构建 Web 应用程序的全功能 MVC 模块。 Mybatis：本是apache的一个开源项目iBatis，后迁移到google code，并改名为Mybatis。它是一个半自动的ORM（对象-关系映射）框架。我们可以通过编写原生的SQL语句来操作数据库。 要准备的东西工欲善其事，必先利其器。Java环境是必须要事先搭好的，具体搭建步骤可以看这里。在正式搭建框架之前，还需要安装相关的环境和软件。下面的内容是针对Java初学者，如果是“老鸟”，请忽略。 安装Maven进入Maven的官方下载站点，下载Maven安装包。直接下载如图所示的安装版本（*-bin.zip），就不必要自己编译了。 注意，不同版本的Maven要求的环境不一样，如果自己电脑不满足最新版本的要求的话，可进入这里或者这里下载更低版本。 将下载下来的压缩包直接解压安装成功，解压后的目录结构如下图所示。请记住Maven的安装位置。 安装EclipseEclipse是最流行的Java集成开发工具（IDE），功能十分强大。虽然近年出现了以IntelliJ IDEA为代码的IDE强力重启，但其仍是使用最广泛的Java IDE。 从官网下载最新版本（代号为Mars）的Eclipse，可选择下图所示的两种不同类型的版本。for java EE版本针对Java企业级开发环境，for java版本针对普通Java开发环境。可以看到for java EE版本比for java版本要大很多，这是因为它集成了更多的功能插件，所以功能也更加强大。不过，也正是由于其功能集成更多，导致其启动速度更慢。可以根据自己电脑配置下载不同的版本，笔者推荐for java的版本。注意，也请根据自己电脑操作系统的版本，下载不同位数的版本。 下载完成后，直接解压即可。解压缩之后的目录结构如下图所示，双击eclipse.exe即可运行eclipse。 安装Jetty和Maven插件安装Jetty接下来安装eclipse下的Jetty插件，有两种安装方式：在线安装和安装包安装。 在线安装。运行eclipse，点击菜单栏中的Help-&gt;Eclipse Marketplace菜单，在搜索框中输入jetty并回车。搜索过程可能会很慢，因为毕竟服务器在国外。选择第一条搜索结果，并点击【install】按钮安装插件。按照下面的图所示的步骤即可开始在线安装jetty插件。最后点击【finish】按钮后，等待期下载并自动安装即可。 安装完成后，eclipse会提示是否restart，点击restart重启。点击【Run】-&gt;【Run Configurations】菜单，如果侧边菜单栏中出现下图中的Jetty WebApp则表示安装成功！ 安装包安装在这里下载Jetty插件安装包，将安装包直接丢入eclipse安装目录下的plugins目录下即可。譬如笔者的eclipse安装目录为：D:\ProgramFiles\eclipse-java-luna-SR2-win32-x86_64\eclipse，则将下载的安装包放入D:\ProgramFiles\eclipse-java-luna-SR2-win32-x86_64\eclipse\plugins目录下即可。按照上面的验证步骤即可验证Jetty插件是否成功安装 上面的安装方式不仅仅针对Jetty插件，所有eclipse插件都可以用类似的方法进行安装。通过情况下，只有运气非常好才能一次安装成功，可能会出现很多种错误。如果安装失败，可以根据相应的错误信息找度娘或者谷歌找寻解决方案 安装Maven插件一般说来，下载的较高版本的eclipse中已自带了Maven插件，所以无需安装。由于内置的版本可能比较旧，我们也可以手动配置Maven，下面就用自己下载的Maven来替换掉它。 打开eclipse，点击【Windows】-&gt;【Preferences】，弹出的窗口面板就是eclipse的配置主面板。选择【Maven】-&gt;【Installations】，点击【Add】按钮。在弹出的窗口中点击【Directory…】按钮，在文件选择器中选择之前安装的Maven的路径，然后点击【Finish】。在复选框中选中刚刚添加的Maven，点击【OK】按钮即可。 一步一步搭建Web工程好了，刀已经磨好了，下面就正式进入开发阶段。 创建简单的Maven Web工程先创建一个Maven Web工程，然后在工程的基础上编写代码。 1、打开eclipse软件，依次点击“File”-&gt;“New”-&gt;“Other”，弹出eclipse的工程选择窗口。 2、点击“Maven”菜单，选择下拉菜单中的“Maven Project”子菜单。 3、勾选【Create a simple project】的复选框，点击“Next &gt;”。 4、填写工程信息如图所示。 上面的主要信息的含义如下： Group Id：项目所属组织的唯一标识符，通常以公司地址+部门的方式填写。每个不同的部分以“.”号分开，所表示的范围从左至右依次减小。目标是从Group Id就能看到该工程出自哪里。譬如Group Id为org.springframework一看就知道是属于Spring。 Artifact Id：项目在组织内的唯一标识符，一般就是项目的名称。 Version：项目的版本信息。如果是以SNATSHOT结尾，则表示该版本不是稳定版本。 Packaging：项目的打包方式，由于是web项目，这里选择war。 点击“Finish”就创建了一个简单的Maven工程，下图是该工程的目录结构。 其中： src/main/java目录放置Java源代码 src/main/resources目录放置资源文件（如配置文件） src/test/java目录方式一些测试用例 src/test/resources目录方式测试利用所需的资源文件 加入SpringMVC框架好了，接下来在所创建的Maven工程中加入SpringMVC的内容，并且创建一个简单的用例来测试是否创建成功。首先看看加入SpringMVC后的整个代码的结构，这是一个SpringMVC项目的最简单、最基本的结构。 下面贴一下各个文件的内容，并对核心内容做了相应的注释。 1、pom.xml：Maven要求的文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;xiale.demo.blog&lt;/groupId&gt; &lt;artifactId&gt;spring-mybatis-webapp&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-mybatis-webapp&lt;/name&gt; &lt;description&gt;简单的spring+mybatis的web应用&lt;/description&gt; &lt;properties&gt; &lt;spring.version&gt;4.2.0.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 配置项目依赖 --&gt; &lt;dependencies&gt; &lt;!-- spring framework --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- serlvet jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、web.xml：jave ee所需要的文件。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;display-name&gt;springmvc+mybatis web项目&lt;/display-name&gt; &lt;!-- 过滤器，所有输出的数据都使用UTF-8编码 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 创建一个Servlet，这是配置SpringMVC的关键。 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatch&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3、dispatch-servlet.xml：spring mvc的核心文件 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!-- JSP视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix"&gt; &lt;value&gt;/WEB-INF/jsp/&lt;/value&gt; &lt;/property&gt; &lt;property name="suffix"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Spring可识别特定注解 --&gt; &lt;context:annotation-config/&gt; &lt;!-- 配置Spring要在哪些基础包下扫描主机 --&gt; &lt;context:component-scan base-package="demo.controller"/&gt; &lt;!-- 配置静态资源的位置及其pattern --&gt; &lt;mvc:resources location="/static/" mapping="/static/**"/&gt; &lt;!-- 配置Spring MVC可识别Controller等注解 --&gt; &lt;mvc:annotation-driven /&gt; &lt;/beans&gt; 4、IndexController：用于检测可用性的一个简单控制器。 12345678910111213141516171819202122package demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * Index控制器，拦截请求并进行业务逻辑处理。 * @author xialei * @version 1.0 2016年3月21日下午8:38:45 */@Controllerpublic class IndexController &#123; /** * 主页映射。表示拦截url path为"/index"的请求。 * @return 返回String类型的数据，表示不附加任何数据，直接将请求转发到index.jsp。 */ @RequestMapping("/index") public String index() &#123; return "index"; &#125;&#125; 4、index.jsp：与IndexController中配置的@RequestMapping(“/index”)所对应的jsp文件。 1234567891011&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello World!&lt;/body&gt;&lt;/html&gt; 大功告成，现在来试着运行一下这个项目，这时需要用到之前安装的Jetty插件。由于是第一次使用Jetty应用，需要进行下面的步骤来生成一个Jetty应用。 首先，依次点击“Run”-&gt;Debug Configurations..”。 其次，选中“Jetty Webapp”，点击左上角的图形按钮新建一个Jetty运行实例如下。 最后，选中刚刚新建的Jetty实例（通常为工程名），点击“Browse…”，在弹出的对话框中选择新创建的Web项目。点击“OK”-&gt;“Run”就开始运行这个Web项目了。如果Console(控制台)中没有出现红色的异常信息，那么恭喜你成功地创建了一个SpringMVC项目。 如果出现下面的信息，则表示项目成功运行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 ____ ___ __ __ __ ___ / __/___/ (_)__ ___ ___ __ / /__ / /_/ /___ __ ( _ ) / _// __/ / / _ \(_-&lt;/ -_) / // / -_) __/ __/ // / / _ |/___/\__/_/_/ .__/___/\__/ \___/\__/\__/\__/\_, / \___/ /_/ /___/ Configuration: C:\Users\xialei\AppData\Local\Temp\eclipseJettyPlugin.spring_mybatis_webapp.xml Version: 8.1.12.v20130726 Context: / Port: 8080 Classpath: E:/repositorys/mavenRepository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar E:/repositorys/mavenRepository/commons-logging/commons-logging/1.2/commons-logging-1.2.jar E:/repositorys/mavenRepository/org/aspectj/aspectjweaver/1.8.6/aspectjweaver-1.8.6.jar E:/repositorys/mavenRepository/org/springframework/spring-aop/4.2.0.RELEASE/spring-aop-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-aspects/4.2.0.RELEASE/spring-aspects-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-beans/4.2.0.RELEASE/spring-beans-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-context-support/4.2.0.RELEASE/spring-context-support-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-context/4.2.0.RELEASE/spring-context-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-core/4.2.0.RELEASE/spring-core-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-expression/4.2.0.RELEASE/spring-expression-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-jdbc/4.2.0.RELEASE/spring-jdbc-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-tx/4.2.0.RELEASE/spring-tx-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-web/4.2.0.RELEASE/spring-web-4.2.0.RELEASE.jar E:/repositorys/mavenRepository/org/springframework/spring-webmvc/4.2.0.RELEASE/spring-webmvc-4.2.0.RELEASE.jar E:/workspaces/eclipse/demo-blog/spring-mybatis-webapp/target/classes2016-03-21 22:42:19.538:INFO:oejs.Server:jetty-8.1.12.v201307262016-03-21 22:42:20.168:INFO:/:Initializing Spring FrameworkServlet &apos;dispatch&apos;三月 21, 2016 10:42:20 下午 org.springframework.web.servlet.DispatcherServlet initServletBean信息: FrameworkServlet &apos;dispatch&apos;: initialization started三月 21, 2016 10:42:20 下午 org.springframework.web.context.support.XmlWebApplicationContext prepareRefresh信息: Refreshing WebApplicationContext for namespace &apos;dispatch-servlet&apos;: startup date [Mon Mar 21 22:42:20 CST 2016]; root of context hierarchy三月 21, 2016 10:42:20 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions信息: Loading XML bean definitions from ServletContext resource [/WEB-INF/dispatch-servlet.xml]三月 21, 2016 10:42:20 下午 org.springframework.web.servlet.handler.SimpleUrlHandlerMapping registerHandler信息: Mapped URL path [/static/**] onto handler &apos;org.springframework.web.servlet.resource.ResourceHttpRequestHandler#0&apos;三月 21, 2016 10:42:20 下午 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping register信息: Mapped &quot;&#123;[/index]&#125;&quot; onto public java.lang.String demo.controller.IndexController.index()三月 21, 2016 10:42:21 下午 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter initControllerAdviceCache信息: Looking for @ControllerAdvice: WebApplicationContext for namespace &apos;dispatch-servlet&apos;: startup date [Mon Mar 21 22:42:20 CST 2016]; root of context hierarchy三月 21, 2016 10:42:21 下午 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter initControllerAdviceCache信息: Looking for @ControllerAdvice: WebApplicationContext for namespace &apos;dispatch-servlet&apos;: startup date [Mon Mar 21 22:42:20 CST 2016]; root of context hierarchy三月 21, 2016 10:42:21 下午 org.springframework.web.servlet.DispatcherServlet initServletBean信息: FrameworkServlet &apos;dispatch&apos;: initialization completed in 1170 ms2016-03-21 22:42:21.442:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:8080-------------------------------------------------Jetty startup finished in 2.256 s.Used memory: 9.8 MB of 77.5 MB (894.5 MB maximum)------------------------------------------------- 注意，如果不是第一次在该项目上运行Jetty，如下图所示，先点击工具栏中的红框所示的按钮，在下来应用中选择自己的Jetty应用就可以直接运行了。 我们在浏览器中测试一下是否真的创建成功。打开浏览器，在地址栏中输入http://localhost:8080/index，如果出现下图所示的内容，则表示web项目成功创建了。 总结本文介绍了从零开始搭建一个最简单的SpringMVC Web应用，该系列的下一篇介绍如何在应用中加入数据库，并使用mybatis来操作数据库。 本文由xialei原创，转载请说明出处http://hinylover.space/2016/03/23/springmvc-mybatis-createproject-demo-1/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从零开始搭建Java环境]]></title>
      <url>%2F2016%2F03%2F23%2Finstall-and-config-java%2F</url>
      <content type="text"><![CDATA[虽然关于如何搭建Java环境是一个非常基础的问题，随便搜索一下就能找到不计其数的Java安装和配置的文章，但那些都是别人的知识。只有自己亲自动手写下来才能转化为自己的知识。搭建Java环境的具体步骤有时会比较模糊，写成文方便自己能够快速找到搭建方法。 安装JDK首先，确定自己的操作系统以及版本。以Windows操作系统为例，右击【我的电脑】，点击【属性】。在下图所示的位置上就可以看到Windows操作系统的版本。 其次，在Oracle官网上下载合适的Java安装程序。由于笔者的操作系统是64位的windows，所以选择下图所示的红线框内的JDK版本。然后按照一般的程序步骤安装即可。请务必记住自己的安装目录，一般情况下，如果没有自定义安装位置，则通常安装在C:\Program Files\Java目录下。 配置环境安装完成之后，还需要配置相关的环境变量。首先打开环境变量的配置窗口，右击【我的电脑】，点击【属性】菜单如下图。 点击左侧菜单中的【高级系统保护】，然后点击弹出框中的【环境变量】按钮，如下图所示。接下来就可以配置环境变量了。 1、配置JAVA_HOME环境变量点击【新建】按钮，在弹出的对话框中输入值。其中变量名处输入JAVA_HOME，变量值输入Java的安装目录，点击【确定】按钮。如果在安装时没有自定义安装路径，则输入C:\Program Files\Java{java_version}，其中{java_version}取决于你安装的Java版本。譬如我安装的Java版本为jdk1.8.0_65，那么输入的变量值就是C:\Program Files\Java\jdk1.8.0_65，如下图所示。 2、配置CLASSPATH环境变量与JAVA_HOME的操作相同，只不过变量名输入CLASSPATH，变量值输入.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar(注意前面的.，表示classpath包括当前路径)。 3、配置Path环境变量在系统变量中找到Path的环境变量，选择这个变量，然后点击【编辑】按钮，在弹出的对话框中的末尾加入;%JAVA_HOME%\bin 经过以上步骤后，按理来说就配好了Java编译和运行环境了。下面来测试一下。键盘上点击win+R组合键，在弹出的输入框中输入cmd进入DOS命令界面。1、输入javac命令，如果出现如下所示的界面，则表示java编译器配置正常。 2、输入java命令，如果出现如下所示的界面，则表示java运行时环境配置正常。 如果输入命令后显示的是【’xxx’ 不是内部或外部命令，也不是可运行的程序或批处理文件。】，则表示配置不正确，需要参照上面的内容检查一下是否哪个地方配置不正确。这种提示表示windows操作系统找到命令所在程序的路径，也就是在Path变量下找到命令程序。可以在DOS下输入echo %Path%，找到与java相关的变量值，看看java程序的路径是否正确。 本文由xialei原创，转载请说明出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[短暂的“歧途”——写在短暂的第二份工作结束之时]]></title>
      <url>%2F2016%2F03%2F15%2Fsecond-job-summary-and-thinking%2F</url>
      <content type="text"><![CDATA[距离上一份工作结束总结才过去3个月，现在又要写第二份工作总结了。不用说，这份工作绝对是不太如意的。其中有不少需要总结的地方，希望读者也能从中吸取经验和教训。 记事去年9月，还在第一份工作期间，跳槽的心就已经扑通扑通在跳动了。期间也请假面了两家公司，一家工资没谈拢，一家没有过一面。恰好此时，已经离职的同事问我想不想去他们公司。这是一家刚刚成立才几个月的初创公司，加上老板、管理和开发人员一共才4人。听了他们的项目计划和产品领域，觉得还挺靠谱的。一则老板的行业经验丰富，二则不缺资金，三则产品思路不错。经过一小段时间的思虑，决定去这家听起来还挺有前途的公司，由此开启了第二段工作经历。 第一家工作的工作比较繁忙，我又在这边多呆了两个月才去到那边。由于是创业公司，每个人身上的活都会很重，我单独负责一个项目，包括需求、设计和开发。老板在北京有一个公司，广州这边的公司可以看做是一家分公司，客户和业务都在北京那边。刚入职后不久，就出差去了北京。当第一次接触到老板的“公司”之后，很快就萌生了退意。说实在的，在我看来那根本不能称得上是一家公司，因为它只有公司的形，而无公司的神。员工是通过一个个的项目组织在一起的，没有正经的、固定的办公场所。公司的存在可能更多的是出于报账、发工资等因素，更别提有什么公司文化了。 从入职到萌生辞职之意之间仅有半个月左右，但是我最终还是没有走。一来觉得对不起叫我过来的朋友，二来想着如此短暂的工作经验不利于职业生涯。但是，老板难以沟通，管理上的无序和不合理，以及个人越来越低的情绪都告诉着我不得不走了。原本打算年前就提离职的，但投了简历之后，各种被拒。我心想着可能是太短的工作履历让各大公司的HR将我的简历扔进了垃圾桶吧。 总结一下离职的原因： 个人的兴趣。在接手工作之时，我觉得向我这样的全才是完全有能力把工作做好的。然而现实却无情地嘲笑着我，我并不如自己预期般全能。我发现个人的兴趣点在于技术研究，在技术资料时会非常兴奋，而在做其他事情时总是不那么主动。 组织结构不合理。真正干活的是我们3个技术出身的码农，大家更感兴趣是技术的研究，探讨技术总是比探讨其他东西时气氛更加活跃。做管理的老大还在其他公司任职，根本无暇管理这边公司的事宜。团队中缺乏专业的产品人员，缺乏与北京那边的沟通人员，导致项目进度缓慢。 老板难以沟通。老板在行业里混了十来年，积累了丰富的行业经验，从业务上来说行业资深人士。但是性格比较“古怪”，感觉很难沟通，不是我一个人有这种感觉，大家都有。可能是他认为自己经验比我们丰富，只要跟他聊业务上的事，基本上没有插上嘴的可能。语速极快，普通话不标准，导致根本跟不上他的节奏。当一通业务说完之后，他就以为他已经把需求和业务全都跟我们明白了。当实现的东西不符合其预期时，免不了一顿批。 行业。这个行业属于传统垄断型行业，国家完全控制，行业成长空间不大。行业内部的人缺乏上进心，对当前的形势反应迟钝，并不断阻碍改革。他们对系统的要求不高，功能够用就行，最重要的是可能拿到经费。如果长时间要跟他们打交道，内心实在是抗拒。 所失短短3个月的时间，对于个人职业发展来说失去了一些东西。 损害职业生涯如此短的工作经历显然对整个职业生涯是相当不利的，用人单位看到这么一段工作经历之后，会下意识地觉得此人不踏实，最终自己找工作的历程也证明这一点。在第一家公司时期，在猎聘网上刷新了一下简历，就有各种猎头打电话询问情况、推荐工作，那会飘飘然地觉得自己很抢手，现在想想实在是有些可笑。前一段时间投简历，很多都石沉大海，也只是寥寥几通推荐工作的电话打过来，前后对比起来着实反差很大。我个人认为主要是由这一段短暂的工作经历所导致的，原因他们觉得在我身上的“投资回报率”会很低。这个“污点”可能短期内是无法抹去了，只有等到下一份踏实的工作经历之后才有可能“稀释”。 技术学习时间在创业公司里，每个人都分配有多种不同的角色，需求、谈业务、开发、测试等，甚至还会有推广。这时候自己学习技术的时间相较以前就少了许多。即使有时可能没什么事情也不好意思做工作之外的事情，因为老感觉身上压着担子，不干“正经事”会觉得对不起老板。当然，会学到不少其他的东西，如行业、业务、待人接物甚至是社会黑暗，但这些并不会让人兴奋，看的越多、越深越没有了干下去的动力。就技术来说，这几个月绝对是退步了，不少旧的知识开始遗忘，而新的知识又得不到补充。 激情在3个月的时间里，情绪低落的时间多于一半。想着公司的现状、老板的能力、行业的落后，貌似没有刺激工作热情的东西。每天更多地是想着赶紧离开，但是有苦于各种因素而迟迟不能行动。矛盾的心理导致工作效率极端底下，又会觉得对不起自己拿到的工资！工作激情的丧失，蔓延到其他方面。很久没有写博客，每每想动手写上一篇，却因低落地情绪而终止。也很久没有运动健身了，以前还能跟同事周五去打打羽毛球，离职之后基本就没有运动过了。失去激情的生活是痛苦的，犹如行尸走肉一般。 人际交往机会办公室一共才3个人，每天大家都各自忙各自的事情，就午饭时间能聊聊天。一天到晚都没能说上几句话，憋着地感觉也是挺不爽的。失去了与人交往、交流的机会，也失去了提高人际交往能力的机会。 所得当然，这3个月也不是白白地过了的，也收获了一些东西。 人生阅历不管好歹，这都算一段人生的阅历。比较深入地接触到一个行业，里面好的、不好的都是客观存在的实现。听着在这个行业里摸吧滚打十来年的过来人讲授的经验，算是对世界有了更深地认识。只有亲身去体会才知道自己到底能做什么、想做什么、不想做什么。人生的阅历都是一步一步积累起来的，短期来说这可能是一次比较失败的经历，但长远来说这无疑是一笔财富。 更加确定自己的方向失败的经历删减了“决策树”上的一个分支，让自己更加明白自己导致想做怎么样的事，想要怎么样的生活。经过这一次之后，我应该更加坚定走技术路线的决心，也会全身心地投入到技术研究上去！ 所省吾日三省吾身——为人谋而不忠乎？与朋友交而不信乎？传不习乎？ 虽然不能像古人一样每日一省，但是阶段性的反省是非常必要的。 太天真不得不说我有时实在是太天真了。我天真地以为加入一个创业公司，我就要做出受欢迎的产品，拿到股票和奖金，从此走上人生巅峰。在做决定以前，没有经过深思熟虑，无视女朋友的意见，固执地坚持自己的意见。真的应该成熟了，要适应一个社会人的身份了。社会远没有当初想象的那么简单，有人的地方就有江湖。 太心急由于念了2年半的研究生，加上毕业时找工作不太如意，薪资与本科毕业直接工作的同学的差距较大。这时的心理及其不平衡，于是想着能通过跳槽来缩小与他们的薪资差距。这种心理过于强烈，导致在做决定时操之过急。很多前辈都会告诫我，刚出来时不要太过在意薪酬，最重要的是学到东西，这才是核心竞争力。 现在要做的就是踏踏实实地在工作岗位上，做好自己本职工作的同时，不断学习。可以向身边的学习，可以阅读，可以实践。成功没有捷径，欲速则不达也。 太自大可能是读书太久，心气很大，觉得自己很牛逼。很多事情心理觉得非常容易做，也不怎么向经验丰富的前辈学习，觉得有点“丢份”。盲目的自大，找工作时报明显高于自己水平的价位，导致丧失了不错的工作机会。 找好自己的定位，做好每一件事。存在即合理，再简单的事情，把它做好就能收获。可以自信，不应该自大。 前面的路截止到博客发表，笔者已经找到了第三份工作，这将是一份相对长久的工作，至少在已经工作的几天里，我找到了长期工作的理由。前面的路必然不是一帆风顺，踏实做好自己的工作。同时，百尺竿头，更进一步，希望每天都能进步一点点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016-3-1博客迁移]]></title>
      <url>%2F2016%2F03%2F01%2Fmigrate%2F</url>
      <content type="text"><![CDATA[准备将CSDN上的所有博客都转移到个人小站上来了。 以后一定要多多写博客！！手动加油！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《HTTP权威指南》学习笔记（2）-HTTP报文]]></title>
      <url>%2F2016%2F01%2F19%2Fhttp-learn-booknote-2%2F</url>
      <content type="text"><![CDATA[上一篇文章写了HTTP协议中的基本概念和URL，这一篇要来讲一下HTTP协议中的报文本身。如果说HTTP是Internet的信使，那么HTTP报文就是它用来搬东西的包裹了。本文包含以下内容： HTTP报文的组成部分 HTTP报文的语法结构 HTTP方法 HTTP状态码 HTTP首部（Header）详解 自己的一些读后的总结和感悟 HTTP报文的语法HTTP是基于请求/响应模式的通信协议，所有的HTTP报文可以分为请求报文和响应报文。请求报文会向Web服务器请求一个动作，响应报文会将请求结果返回给客户端。 语法结构请求报文和响应报文的基本结构非常类似，下面是请求报文的语法结构： 1234&lt;method&gt; &lt;request-url&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 下面是响应报文的语法结构： 1234567&lt;version&gt; &lt;status-code&gt; &lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt;&lt;headers&gt;&lt;entity-body&gt; 可以看出，请求报文和响应报文的语法仅仅在起始行（第一行）处有所不同。下面对报文的各个部分做简要描述。 方法（method）：表示客户端对资源执行的动作，是一个单独的动词，比如GET、POST等。请求资源的URL（request-url）：表示请求的资源的URL，关于URL的知识已经在上一篇文章中介绍了。协议版本（version）：表示所使用的HTTP的协议版本，其格式为：HTTP/.，其中major表示主版本号，minor表示次版本号。状态码（status-code）：表示请求过程中所发生的情况，是一组三位数的数字。关于状态码会在接下来的内容介绍。原因短语（reason-phrase）：状态码的可读版本，是对状态码的解释，对人类来说是可读的。首部（header）：表示请求或响应中的附加信息，可以有零个或多个首部，每个首部项都是形如name: value的字符串，每个首部项后面都以CRLF（回车+换行）结束。实体的主体部分（entity-body）：包含任意格式的数据块，是Web应用的主体内容。 HTTP报文的组成部分HTTP报文包括请求报文和响应报文，由起始行（start line）、首部（header）和主体(body)三个部分组成，其中起始行和首部是必有的，主体部分是可选的。 起始行(start line)所有的HTTP报文都以一个起始行作为开始，请求报文起始行说明要做什么事，响应报文的起始行说明发生了什么事。 请求起始行请求报文请求对服务器中的资源进行一些操作，包含请求方法，请求URL，在有些版本的协议中还需要加入HTTP协议的版本。一个典型的请求报文的起始行如下： 1GET /test/hi-there.txt HTTP/1.1 注意，URL部分并不包含主机信息，不是完整的路径，而是具体服务器上的资源路径。主机（host）的信息会包含到首部中，首部会在接下来的内容中介绍。 响应起始行响应报文承载着响应状态信息和操作产生的结果数据，并返回给客户端。响应起始行包含着HTTP版本、数字状态码以及描述操作状态的文本形式的原因短语，每一部分之间用空格分隔。一个典型的响应报文的起始行如下： 1HTTP/1.1 200 OK 首部(header)首部是向请求或响应报文中添加的附加信息，本质上来说，是一些key:value列表。下面列出了一些平常常见的首部。 123456Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CN,zh;q=0.8,en;q=0.6,ja;q=0.4,zh-TW;q=0.2Cache-Control:max-age=0Host:www.csdn.netUser-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36 由于首部全部都是文本，所以首部是可扩展的，只要服务端支持即可。首部字段可以分成下面几类： 通用首部：可以同时用于请求和响应报文，比如Date首部。 请求首部 响应首部 实体首部 扩展首部 首部内容是HTTP中的重点内容，在实际开发过程中需要时常与之接触，详细内容将接下来的单独介绍。 主体(body)主体是HTTP报文实际负载的内容，具体来说，就是应用程序数据。Web开发者要做工作就是编写这部分内容。主体类型非常丰富，可以是：图片、视频、HTML文档、电子邮件等。所以HTTP协议为什么将超文本传输协议，就是因为其负载的内容并不局限与文本。主体的类型有上层开发者负责，HTTP协议对它并没有做很多约束和限制。 HTTP方法方法告知服务器要做什么操作，位于请求报文起始行的开始位置。HTTP协议中规定的主要方法有： GET：最常用的方法，用户请求服务器上的某个资源。 HEAD：与GET方法的行为很类似，但在服务器响应中仅返回首部，不会返回主体数据。 PUT：与GET方法相反，PUT回向服务器中写入文档。PUT的语义是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档。或者，如果那么URL所对应的资源已经存在的话，这个请求中的主体来替换原来的文档。 POST：向服务器中发送数据。实际上，通常会用它来支持HTML表单。^footnote DELETE：请服务器删除请求URL所指定的资源。 TRACE：用于“环回”测试和诊断。客户端请求可能要穿过防火墙、代理、网关等中间节点才能达到最终的目的服务器，每个中间节点都可能会修改原始的HTTP请求，TRACE方法允许客户端看到它的请求最终变成了什么样子。下图是一个TRACE过程示例。尽管TRACE可以很方便的诊断，但它也有缺点。它假定中间节点对不同的类型的请求（比如不同的方法）会做相同的处理，实际上，不同类型的请求可能会做不同的处理，譬如，将POST请求直接发到应用服务器，而将GET请求发往缓存服务器。TRACE请求中不能带有实体的主体部分，响应报文中的主体部分是服务器收到的请求的精确副本。 OPTIONS:请求服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者哪些特殊资源支持哪些方法。下面是一个OPTIONS方法示例： 下图是对HTTP协议中主要方法汇总： 上面的方法中，GET和HEAD方法是安全的方法，使用这些方法不会产生什么动作。POST等方法不是安全方法，POST方法会在服务器端生成新数据。假设是个请求扣款操作，多次执行POST操作有可能（如果服务端写的非常糟糕的话）会导致重复扣款。 HTTP状态码HTTP中状态码的作用是告诉客户端发生了什么事，状态码位于响应报文的起始行中。HTTP中状态码使用三位数字来表示，根据最高位数据可以分为下面几类： 可用范围 已用范围 含义 100~199 100~101 信息提示 200~299 200~206 请求成功 300~399 300~305 重定向 400~499 400~415 客户端错误 500~599 300~305 服务端错误 下面来介绍一下使用开发中比较常用的状态码。 1、 100~199（信息性状态码） HTTP/1.1向协议中引入的信息性状态码，由于对其复杂性和感知价值存在争议，因为使用受到限制。 状态码 原因短语 含义 100 Continue 说明服务端了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应 101 Switching Protocols 说明服务器正在根据客户端指定，将协议切换成Update首部所列的协议 2、 200~299（成功状态码） 客户端发起请求时，这些请求通常是成功的。这一段状态码表示成功的状态，分别对应不同类型的请求。 状态码 原因短语 含义 200 OK 请求没问题，实体的主体部分包含了所请求的资源 201 Created 用于创建服务器对象的请求。响应的实体主体部分中应该包含各种引用了已创建的资源和URL，Location首部包含的则是最具体的引用。 202 Accepted 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求，这是意味着接受请求时，它看起来是有效的。通常，该请求执行的是一个异步任务。 203 Non-Authoritative Information 实体首部包含的信息不是来源于源端服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法或没有对它所发送的的资源相关的元信息进行验证，就会出现这种情况。 204 No Content 响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，对其进行更新 205 Reset Content 负责告知浏览器清除当前页面中的所有HTML表单元素 206 Partial Content 成功执行了一个部分或Range请求。 必须包含Content Range、Date以及Etag或者Content-Location首部 3、 300~399（重定向状态码） 重定向响应码要么告知客户端使用替代位置来访问他们所感兴趣的资源，那么提供一个替代的响应而不是替代的内容。如果原来的资源已经被移走，可发送一个重定向状态码和一个可选的Location首部来告知客户端资源已经被移走了。 状态码 原因短语 含义 300 Multiple Chioces 客户端一个请求实际上指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的中文和英文版本。返回这个状态时会带有一个选项列表，这样用户就可以选择他希望的那一项了。 301 Moved Permanently 请求的URL链接已被永久移除， Location中首部中包含资源现在处的URL。 302 Found 与301状态码类似，但是，它表示URL临时移除。客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍然使用老的URL。 303 See Other 告知客户端应该使用另外一个URL来获取资源。新的URL位于响应报文的Location首部。其主要目的是允许POST请求的响应将客户端定位到某个资源上去。 304 Not Modified 客户端可以通过所包含的首部（如If-Modifid-Since），使得请求是有条件的。如果客户端发起一个GET请求，而该资源未被修改，就可以返回这个状态码。响应报文不应该包含主体内容。 305 Use Proxy 用来说明必须通过指定的代理来访问资源，代理的位置有Location首部提供。很重要的一点，客户端是相对某个特定的资源来解析这条响应，不能假定所有的请求都通过这个代理。 306 （还未使用） 还未被使用 307 Temporary Redirect 与302的作用相同，用于HTTP/1.1。 从上表中可以看出，302、303、307的状态码功能非常相似，它们有些细微的差别，大部分差别来源于HTTP/1.0和HTTP/1.1应用程序对这些状态码的处理不同。 当HTTP/1.0客户端发起POST请求，并在收到302响应时，它会接受Location首部的重定向URL，并向那么URL发起一个GET请求（而不是向原始请求的那样发起POST请求）。问题在于，在HTTP/1.1中使用303状态码实现了与HTTP/1.0中的302状态码的相同功能。为了避开这个问题，HTTP/1.1规范指出，对于HTTP/1.1客户端，用307状态码取代302状态码来进行临时重定向。这个服务器就把302状态码保留起来，为HTTP/1.0可以使用了。 这样一来，服务器要选择适当的重定向状态码放入重定向响应中，就需要查看客户端的HTTP版本了。 4、 400~499（客户端错误状态码）有时客户端会发送一些服务器无法处理的请求，比如格式错误的请求报文，或者最常见的是，请求一个不存在的URL。很多客户端错误都是有浏览器来处理的，甚至不会打扰到用户。只有少量的错误，比如404会来到用户的面前。 状态码 原因短语 含义 400 Bad Request 用于告知客户端它发送了一个错误的请求。 401 Unauthorized 与适当的首部一同返回，在这些首部中请求客户端在获取资源前，需进行认证。 402 Payment Required 保留，还未使用？ 403 Forbidden 说明请求被服务端拒绝了。 可以在主体内容中说明拒绝原因，但这个状态码通常用于不想说明原因的场景。 404 Not Found 用于说明服务器无法找到所请求的URL。 405 Method Not Allowed 发起的请求的方法不被服务端支持时，使用此状态码。响应中应该使用Allow首部来告知所请求的资源可使用的方法。 406 Not Acceptable 客户端可以指定参数来说明它们愿意接受什么类型的实体，如果服务器没有与客户端可接受URL相匹配时，使用这个状态码。 407 Proxy Authetication Required 与401的作用相似，但用于要求对资源进行认证的代理服务器。 408 Request Timeout 如果客户端的请求所花的时间太长，服务器可以返回次状态码，并关闭连接。 409 Conflict 用于说明请求可能在资源上引发的一些冲突，服务器担心可能发生冲突时，可以发送此状态码。 410 Gone 与404类似，只是服务器曾经拥有过此资源。主要用于Web站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了。 411 Length Required 服务器要求在请求报文中包含Content-Length首部时使用。 412 Precodition Failed 客户端发起条件请求，且其中的一个条件失败了的使用使用。客户端包含了Expact首部时发起的请求就是条件请求。 413 Request Entity Too Large 客户端所发送的实体比服务器能够或者处理的要大。 414 Request URI Too Long 客户端所请求的的URL长度比服务器能够或者处理的要长。 415 Unsupport Media Type 服务器无法理解或支持客户端发送的内容类型。 416 Request Range Not Satisfiable 客户端请求的资源的范围无法被满足。 417 Expaction Failed 请求的Expact首部包含一个期望，如果期望不能被满足时，使用这个状态码。 5、 500~599（服务器出错状态码）如果客户端发送了一个请求，服务端自身发生了错误，就会返回这么段的状态码。 状态码 原因短语 含义 500 Internal Server Error 服务端遇到一个妨碍它为请求提供服务的错误时，使用此状态码。 501 Not Implemented 请求超过了服务端的能力范围时，返回这个响应码。 502 Bad Gateway 代理或者网关使用的服务器收到链路上的下一个节点的伪响应（比如，无法连接到其父网关）时，使用此状态码。 503 Service Unavailable 用来说明服务器现在无法为请求提供服务，但是将来可以。如果服务器知道服务何时可用，可在响应中包含一个Retry-After首部。 504 Gateway Timeout 与状态码408类似，只是响应来自网关或代理，它们在等待另外的服务器对其请求响应时超时。 505 HTTP Version Not Supported 服务器收到的请求使用了它无法或者不愿意支持的协议版本时，返回此状态码。 下面自己试着总结一下这些HTTP状态码： 4XX错误种类最多。客户端是软件开发者能掌控的最弱的环节，也是可能出错最多的地方； 有些状态码的语义比较模糊（比如400、500），通用性很强，不利于定位错误。所以，在实际开发中应该尽量少用这种语义模糊的状态码。 有些状态码语义有些重叠和相似。比如405和501这两个状态码，虽然405的错误更加明确，但都是表示服务端无法处理这个请求。那么到底是客户端使用了未实现或未允许的方法呢？还是服务器无法处理这个请求呢？语义的重叠带来了开发中的选择困难。 HTTP首部详解首部和方法配合，共同绝对了客户端和服务端能够做什么。在请求和响应报文中都可以用首部来提供信息，按照首部所处的端点和位置可以将首部分成5类： 通用首部：客户端和服务端都可以使用的首部。 请求首部：请求报文中特有的首部。 响应首部：响应报文中特有的首部。 实体首部：对应于实体主体部分的首部。 扩展首部：应用开发者自己创建的首部。 通用首部通用首部提供了一些最基本的信息，下表列出了一些常用的通用首部。 首部 含义 Connection 客户端和服务端指定与请求/响应连接相关的选项。 Date 提供日期和时间标志，说明报文是什么时间创建的。 MINE-Vesion 发送端使用的MINE的版本。 Transfer-Encoding 告知接收端报文采用何种编码方式。 Update 告知发送端可能想要“升级”使用的新版本或协议。 Via 显示报文经过的中间节点（代理、网关）。 Cache-Control 指示缓存方式。 Prama 另外一种随报文传送的指示的方式，但并不专用于缓存。 请求首部请求首部是只在请求报文中有意义的首部。用于说明是谁或什么在发送请求、请求源于何处。可以根据首部的功能来对请求首部进行分类。 1、 信息性请求首部 首部 含义 Client-IP 提供运行客户端的主机IP。 From 提供了客户端用户的Email地址。 Host 提供了接受请求的服务器的主机名和端口。与起始行中的URL路径结合起来，组成了一个完整的绝对URL地址。 Referer 提供了包含了当前URI的文档的URL。 比如，点击URL为www.xx.com的页面中的任意链接，请求中会带上Referer: www.xx.com的首部。 User-Agent 将发起请求的应用程序告知服务端。如果想模拟浏览器请求来做个爬虫，通常都会加上这个首部。 2、 Accept首部Accept首部为客户端提供了一种将其喜好和能力告知服务器的方式。可以告知服务端它们想要什么，可以使用什么，以及不想要什么。服务端可以根据这些首部，来做发送的内容作出更加明智的决定。 首部 含义 Accept 告知服务端客户发送哪些媒体类型。 Accept-Charset 告诉服务端能够发送哪些字符集。 Accept-Encoding 告知服务端可以使用哪些编码方式。 Accept-Language 告知服务端能够发送哪些语言。 3、 条件请求首部通过条件请求首部，客户端可以为请求加上限制，要求服务器在对请求响应之前，确保某个条件为真。 首部 含义 Expect 允许客户端列出请求所要求的服务端行为。 If-Match 如果服务端的实体标记与当前的实体标记相匹配时，就获取这份文档。 If-None-Match 如果服务端的实体标记与当前的实体标记相匹配时，就获取这份文档。 If-Modified-Since 如果请求的文档在指定的日期后修改过，就获取这份文档。 If-Unmodified-Since 如果请求的文档在指定的日期后没有修改过，就获取这份文档。 If-Range 如果服务端支持范围请求，就进行响应。 Range 指定一个请求范围。 4、 安全请求首部HTTP本身就支持一种简单的机制，可以对请求进行质询/响应认证。客户端在请求资源时，需要带上安全请求首部才能获取特定的资源。 首部 含义 Authorization 包含客户端对自身进行认证的数据。 Cookie 客户端向服务端传送的一个令牌。 5、 代理请求首部 首部 含义 Max-Forward 在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数（与Trace方法一同使用）。 Proxy-Authorization 与Authorization首部含义相同，只不过用于代理认证。 Proxy-Connection 与Connection首部含义相同，用于与代理建立连接时使用。 响应首部响应首部为客户端提供一些额外信息，比如谁在发送响应，响应者的功能，甚至与响应相关的一些特殊指令。这些首部有利于客户端处理响应，并在将来发起跟高的请求。 1、 信息性响应首部 首部 含义 Age 从最初创建开始，响应持续时间。 Retry-After 如果当前资源不可用，在此日期或时间重试。 Server 服务器应用程序软件的名称和版本。 Title 对于HTML文档来说，就是HTML文档的源端给出的标题。 Warning 比起始行中的原因短语更加详细的警告信息。 2、 协商响应首部 首部 含义 Accept-Ranges 对此资源来说，服务器可接受的范围类型。 Vary 服务器查看的其他首部的列表，可能会使响应发生变化。也就是说，这是个首部列表，服务器会根据这些首部的内容挑选出合适的资源版本发给客户端。 3、 安全响应首部 首部 含义 Proxy-Authenicate 代理可客户端的质询列表。 Set-Cookie 在客户端设置一个令牌，以便对客户端进行标识。 WWW-Authenicate 来自服务器对客户端的质询列表。 Title 对于HTML文档来说，就是HTML文档的源端给出的标题。 Warning 比起始行中的原因短语更加详细的警告信息。 实体首部有很对首部用来描述HTTP的负荷，由于请求和响应中都可能包含实体部分，所以在这两张报文中都可能出现这类首部。 实体首部提供了实体及其内容的的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体首部可以告知报文的接受者它在对什么进行处理。 1、 信息性实体首部 首部 含义 Allow 列出可以对实体执行的请求方法。 Location 告知客户端实体实际位于何处，用于将接收端定向到资源的位置上去。 2、 内容实体首部内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息。 首部 含义 Conntent-Base 解析主体中相对URL时所使用的基础URL。 Conntent-Encoding 对主体执行的编码方式。 Conntent-Language 理解主体时最适合使用的自然语言。 Conntent-Length 主体的长度或尺寸。 Conntent-Location 资源主体实际所处的位置。 Conntent-MD5 主体的MD5校验和。 Conntent-Range 在整个资源中，此实体表示的字节范围。 Conntent-Type 这个主体的对象类型。 3、 实体缓存首部缓存首部说明了如何或什么时候进行缓存。 首部 含义 Etag 与此实体相关的实体标记。 Expires 实体不再有效，要从原始的源端再次获取此实体的日期和时间。 Last-Modified 实体最后一次被修改的日期和时间。 读后反省读了本节内容，再联系到自己在实际开发过程中对HTTP协议的运用，发现之前用的不正确、不合理。下面是自己总结的用的不正确的地方： 除了post、get方法外的方法，基本上没有用过其他HTTP方法。HTTP是应用层协议，与自己开发的应用程序属于同一个网络层次。只不过它给我们解决了网络应用程序中的通用性问题，让应用软件开发者可以将重心放在应用内容本身。既然HTTP协议本身已经定义了这么多的执行动作的方法，就不应该弃之不用。必然要删除某个资源，完全可以使用delete方法来标志删除动作。 最近在研究rest这种Web应用设计思想，它可以使得应用程序充分运用HTTP协议。 URL误用。URL是资源的唯一标识符，指示资源的位置和获取方式。从语言词性层面来说，这样的描述性短语应该是一个名词性短语，所以诸如www.xx.com/getUsers、/deleteUser?id=11之类URL都属于误用。 很少使用除了200、404、500以外的状态码来描述响应状态。既然HTTP协议与应用数据属于同一个网络层次，如果HTTP中定义的状态码足以描述当前的状态，就应该优先使用它们，而不是使用自定义的状态。 在这篇文章以前，自己已经阅读过HTTP状态码、首部等内容很多次了，但就是记不住。读一遍记不住，读十遍也就是那样。但是，自己这么完整的复写过一遍之后，对整个HTTP协议细节有了更深的认识，而且也能够勉强记住了。好记性不如烂笔头，确实是这么一个道理。虽然把人家书上的内容是照搬了过来，相当了又重复造了一遍轮子，但是对笔者来说却相当收益。技术提高没有什么捷径可走，要的就是更多地去实践，造轮子不失为一种技术提高的有效办法。 总结本文是有关HTTP学习的第二篇的文章，主要介绍了HTTP协议中的报文，包括报文组成、语法结构、方法、状态码和详细的首部介绍。内容以《HTTP权威指南》为主，同时加入了自己的理解。在文章的末尾谈了谈阅读和写完本章内容之后的感想，以及对自己今后开发上可能的帮助。同时也反思一下自己本身的不足，要好好加油才是！本文历时了2个多星期才写完，不是因为时间不够，实在是懒癌症太厉害了。而且，工作上也不是很如意，有时候回家后啥都不想干。最后还是写完了，坚持就是胜利。Keep learning！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《HTTP权威指南》学习笔记（1）-HTTP概述和URL]]></title>
      <url>%2F2015%2F12%2F29%2Fhttp-learn-booknote-1%2F</url>
      <content type="text"><![CDATA[引言HTTP协议，一个熟悉又陌生的应用协议。熟悉的是它在各种计算机网络教材中必然会被提及的应用层协议，稍微有点计算机知识的人基本上都会听过这个协议。它是互联网的基础，可以这么说，没有HTTP协议，就没有当前互联网的蓬勃发展。然而，笔者对它又是陌生的。因为虽然参与开发了不少Web应用，但很少直接与HTTP协议直接打交道，因为Web容器隐藏了很多HTTP协议的细节（譬如：请求协议头的解析，响应报文的生成），使得上层开发不用关心HTTP即可以开发出可用的Web应用。不应该仅仅满足可用，还应该让应用更加高效，这促使我不得不去研究HTTP协议。私以为，如果想进一步提升自己的技术能力，必须要深入到协议层级别，一些平时感觉到莫名其妙的问题就可以迎刃而解。 最近阅读了《HTTP权威指南》一书，本文包含书中的核心要点、个人延伸以及个人操作实践。由于本书是2009年出版，距现在已经有6年之久，期间，HTTP协议本身也不断地发展。所以，一些老旧的知识点将不会出现在本文中。希望通过不断阅读和实践，并且记录下来，能够加深对HTTP协议本身的理解！ HTTP协议概述本节介绍一些HTTP的基础知识，先对HTTP有一个宏观上的了解。 HTTP协议是什么平常老看到TCP/IP协议、FTP协议，XX协议……不禁要问，到底什么是协议？查阅了百度百科，上面是这么定义的： 基本解释：共同计议；协商法律范畴：协议是指两个或两个以上实体为了开展某项活动，经过协商后双方达成的一致意见。 感觉上面的解释有些简单和抽象，但是从中不难看出协议有下面两个要点： 两个及两个以上参与者。也就是说，如果只有一方参与，根本就不会涉及到协议。 协商一致。也就是说，所有参与方都必须同意并且遵守，才能使得活动能正常运行下去。 上面讲的一般意义上的协议，在计算机领域中，我们讲的协议一般是指通信协议，它仍然遵循上面的要点。首先，通信必然涉及到多方参与；其次，如果有一方不遵守协议，则根本没法进行有效通信。 下面来看看啥是HTTP协议，百度百科是这么说的：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。 HTTP协议的特点下面从这篇博客中转过来的HTTP协议的特点，这篇文章对HTTP做了很全面的介绍，值得一读。 支持客户/服务器模式。支持基本认证和安全认证。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 HTTP 0.9和1.0使用非持续连接（无连接性）：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大 特别直接说明的是HTTP的连接性。在我以前的认识里，HTTP最重要的特性是无连接性和无状态性。所谓无连接性，是指每一次请求都使用新的连接，请求完毕后连接关闭。这样做最大的好处时，最大程度上减少空闲连接占用服务端资源，这在系统资源比较昂贵、页面比较简单、仅传输静态页面的年代确实是非常合理的。但是，随着电商、视频等富媒体Web应用的兴起，HTTP的无连接性制约了系统的性能。一个Web应用动辄上百张图片，每一张图片都要占用一个网络连接。要知道，每新建一个连接都需要在TCP协议层进行“三次握手”，效率非常低下。随着在HTTP v1.1版本中默认采用Keep-Alive，多个请求可以使用同一个连接，HTTP的无连接性描述已经变得不准确了。 版本变化 HTTP/0.9 已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。 HTTP/1.0 这是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。 HTTP/1.1 当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。 URL与资源什么是URLURL（Uniform Resource Location, 统一资源定位符）是Internet上的所有资源的标准化名称。可以把Internet看做一个巨大的正在扩张的城市，里面充满了各种可看的东西，可做的事情。我们需要为这个城市里面的所有景点和服务起一个名字，所有的名字必须在符合统一的标准，这样才能使得我们方便地使用这座城市的宝藏。URL就是其中一类重要的资源命名方式。URL指向每一条电子信息，告诉你它位于何处，如何与之进行交互。URL必须是唯一的，也就是说，一个URL只能对应唯一的资源。 URI、URL和URN说起URL，就必然要提URI和URN。那么它们之间到底有什么联系和区别呢？首先来看看URI和URN是什么。 URI：即Uniform Resource Identifier，统一资源标识符。它是一个通用的概念，理论上，能保证资源全局唯一性的标识符都可以叫做URI； URN：即Uniform Resource Name,统一资源名称。这样的资源名是与资源具体的位置无关的。 URI、URL、URN是相互关联的。URL和URN都是URI的子集，按照集合论的观点，它们之间的关系见下图。 也就说，任何的URL都可以是URI，反之不然。URL是与资源所处的位置密切相关的，如果资源挪动位置，则必然导致URL跟着一起变化。想象一下，如果资源换了位置（虽然这极少发生），则原来开发的软件就会失效。URN主要就是为了解决这个问题而提出来的。它通过给资源命名而不是定位来唯一地确定资源。 假定现在要给我起个独一无二的名称，我可以自己命名为此时我所处的地理位置,假设是(东经36度，北纬36度)。好了，现在请叫我(东经36度，北纬36度)，通过地图肯定可以找到我。然而，我并不是时时刻刻都呆着这里的，因为我是个活人。当我移动位置之后，通过原来的位置定位到的已然不是我了，这就很麻烦了。如果用我的姓名来找我（假设是独一无二的），则无论何时何地找到的都是我了。 目前来说，URN貌似还没能到实用阶段，看上去用处也不大。一则资源位置一般不会发生变动；二则URL已经完全普及，为啥要抛弃已经用得溜溜的东西呢？！至少目前还没有理由这么干。所以，在《HTTP权威指南》一书中，并没有将URI和URL区分开来，所有的URI都可以看做是URL。 URL的完整语法在Web应用中，URL通常是由3各部分构成，以URL地址http://www.joes.com/seanonal/index.html为例来进行说明。 第一部分(http)是方案（schema），可以告知客户端怎样访问资源。 第二部分(www.joes.com)是服务器的位置，告知客户端资源位于何处。 第三部分（/seanonal/index.html）是资源路径。 上面的URL地址只是众多格式的URL地址中的一种，实际上，URL还可以通过HTTP以外的其他协议来进行访问。比如个人E-mail账户：1mailto:xialei199023@163.com 或者是通过FTP协议获取文件：1ftp://ftp.xxx.com/file.xls 咋一看，这些URL的格式都不太一样，这是不是意味着每种不同的URL方案会有完全不同的语法呢？其实不然。大多数URL语法都建立在9个部分构成的通用格式上： 1schema://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;&lt;/pre&gt; 每一部分的的意义如下： schema：获取资源时使用何种协议 user：访问资源时需要的用户名 password：访问资源时与用户名配套的密码 host：资源所在的服务器地址 port：服务器所监听的端口 path：服务器上的本地资源路径，用/分隔 params：指定输入参数，用key/value表示 query：资源查询参数 frag：资源内部的片段名字 URL通常会由其中的某些部分组合而成，下面是一些URL典型示例： 123456http://www.joes.com/seanonal/index.htmlfile:///D:/relativeUrl.htmlftp://username:password@ftp.xxx.com/file.xlshttp://www.joes.com/seanonal/index.html;type=dhttp://www.joes.com/seanonal/goods.html?item=45454http://www.joes.com/seanonal/goods.html?item=45454#name 相对URL绝对URL和相对URL是URL的两种不同的表现形式，前面所有的URL示例都是绝对URL，绝对URL包含访问资源所需的全部资源。下面是一个简单的HTML页面代码，其中的page1就是一个包含相对URL的链接。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;page2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="./page1.html"&gt;page1&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 相对URL是不完整的，要获取资源的全部信息，还要依赖称为基础（base）的URL。基础URL通常来自以下地方： 第一，在资源中显示提供。在HTML文档中，可以由&lt;base&gt;标签定义一个基础URL。下面的代码定义了&lt;base href=”http://www.demo.com/base/&quot;&gt;&lt;/base&amp;gt;，于是，page2实际的绝对地址就是：http://www.demo.com/base/page2.html。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;page1&lt;/title&gt; &lt;base href="www.demo.com/base/"&gt;&lt;/base&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="./page2.html"&gt;page2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 第二，所属资源的URL作为基础URL。还是以上面的代码为例。假定page1.html的绝对URL是http://www.demo.com/page1.html，那么page1.html属于http://www.demo.com/资源下的。直接用这个地址作为基础URL，则page2的绝对URL是：http://www.demo.com/page2.html。 第三，没有基础URL。注：这里没有看懂，先列在这里…… URL编码合格的URL应该满足下面的要求： 可移植性：作为统一的命名，应该要能够通过不同的协议来传送资源。不同的协议可能会有特定的保留字符，在不同的协议中传输时，不应该因为这些特殊字符而丢失信息。 可读性：不可见的、不可打印的（比如空格）字符不应该出现在URL中。 完整性：可能需要通用字符外的二进制数据或字符，因此需要一种转义机制，将不安全的字符编码为安全字符。 从历史来看，计算机应用程序都是用US-ASCII字符集^footnote。由于其历史悠久，所以可移植性很好。但是它不支持数百种非罗马语言中的字符。这就需要一套转义编码机制，用US-ASCII字符集来对任意字符进行编码。目前设计的转义表示法是用一个“%”，后面跟着两个表示ASCII码的十六进制数。下面是一些编码示例： 字符 ASCII码 示例 ~ 126(0x7E) http://www.baidu.com/%7E（http://www.baidu.com/~） 空格 32(0x20) http://www.baidu.com/?query=http%20url（http://www.baidu.com/?query=http url） % 37(0x25) http://www.baidu.com/?query=1%255（http://www.baidu.com/?query=1%5） 总结本文是《HTTP权威指南》学习笔记的第一篇，介绍一些HTTP中的基本概念和概述。重点介绍了URL（统一资源定位符）这一种最重要的Web资源命名方式，将其与URI、URN这类经常混淆的概念进行的比较。概要说明了URL的语法格式、相对URL和URL编码。首先对HTTP有一个整体上的认识，接下来要写的是HTTP中的重要细节内容，与日常的开发密切相关。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[生活开场曲--写在第一份工作结束时]]></title>
      <url>%2F2015%2F12%2F14%2Ffirst-job-summary%2F</url>
      <content type="text"><![CDATA[职场开始2015年11月27号，应该是我人生中一个非常重要的日子，我离开了工作1年半的公司。这是我的第一家公司，我是职业生涯开始的地方。工作的时候更多的是在干活，都没有时间（就算有时间，也没有想过）对目前的工作生活做一下总结，是时候好好总结一下这一年多的工作和生活了，无论是收获、遗憾，都应该要成为我的财富。 从离开校园到上班之前2014年4月20日，离开了学习7年的学校，离开了生活7年的城市，我和女朋友南下来到了广州这个陌生的城市。由于各自的公司都没有安排宿舍，我们要做的第一件事就是租一个房子，不需要太大，能够助人即可，最好能够比较便宜。在58同城上搜索着各种房源，希望能找到一个离双方都比较近的地方。如果不成，找一个离地铁站近的地方也行。我们都不是喜欢挑选太久，因为兜里实在是没什么钱，挑选范围就是那么点大，没什么必要。人家说，凡是有选择恐惧症的人都有一个特质，那就是穷!最终敲定了一个城中村。说真的，刚开始其实对城中村是没有什么概念的，以为就是普通的出租房，无非是靠出售祖传土地获取大量“楼盘”的人向那些外来打工的出租。联系好了房东看房，房东让我们自己过去，按照地图指引的路线，硬是没有找到地方。虽然在大北京呆了7年，仍然分不清东南西北。房东在电话了说要先往南走多远，然后再往西走多远，我们当时的内心其实是崩溃的。后来直接说了一个有显著特征的建筑才找到的，也不早点说…… 到了地方之后，发现每一栋楼紧紧地挨在一起，后来知道这叫“握手楼”。“村子”里基本上住的都是外地人，有像我们一样刚刚毕业的年轻人，有拖家带口的一大家子，有做小生意的夫妻，好不热闹。我惊讶地发现我们的房东居然也是给人打工的，有点颠覆我的认知。真正的老板原来啥都不用干，坐等着收钱就行了，租都不用自己亲自收。房东带我们看空置的房子，每一个房子格局感觉都差不多，就是朝向不太一样。“房东”向我们介绍顶楼的房间，说是光线和空气都不错，但是房子的使用人要下一月才能搬走。没办法，最终挑选了一个7层的一居室，先这么住着，等到下一月在搬到顶楼去。 2014年4月22日，我们住进了“属于”自己的房子。虽然不是真正属于自己的房子，但我们可以随心所欲地在这里生活，完全有别于过去的学生宿舍。虽然房间的条件也不太好，但是对于刚出校园的我们来说非常满足。出租屋里只有简单的家具（衣柜、小书桌和一张“裸奔”的床），搬进去的第一件事就是购买生活必需品。像我们这种没有太多社会生活经验的人，最先想到了就是大超市。刚开始，什么都想买，购物车越堆越高。后来实在是觉得拿不下了，遂减少些不必要的东西。不得不说，花钱的感觉简直是太爽了，不过付钱时就另外的心情了。清晰地记得一共花了差不多500块大洋，那叫一个心疼啊！在没有工资收入之前，这就花掉了不少积蓄了。两个人拎着一些锅碗瓢盆、床单被罩屁跌屁跌地回去了。后来才猛然醒悟，有些东西其实到两元店买就行了，便宜又实惠。 想想一直吃着老本也不是办法啊，赶紧联系HR，看看能不能让我早点入职。得到的答复是要五一之后才能入职，不过可以先去体检。好吧，那就先去体检吧。来到指定医院后，二话不说直奔旁边的体检中心，去里面等了老半天，越想越不对劲，平常的体检绝对不是这样的啊。后来HR到了之后，问我到哪了，我说已经在里面了，她找了一会也没找到我。他问我是不是找错地方了，于是问了体检中心里面工作人员，果然是错了（囧）。于是，轻轻地走出了体检中心，再仔细看了看门外的牌匾，写的貌似是“飞行员体检中心”。虽然经过一小段插曲，体检最终也是顺利搞定，。体检的地方貌似离公司也不远，趁着这个机会，也去探了探路。 等了10多天，终于等到开始报到的日子。2014年5月4日，我可能不能一下子记起这是五四青年节，但是我肯定会记得这是我人生新阶段的开始。 重要的时间节点1年半的时间，对整个职业生涯来说不长，也没有什么高潮迭起、荡气回肠。理出一些特殊的时间节点，在这些时间节点内发生了对以后都有影响的事。 2014-05-04：正式开始上班。2014-05-14：开始写工作记录，没有很详细，只是在Excel里写当天的主要工作内容。事实证明，这是一个好习惯，一定要坚持！2014-05-15：第一次参加工作小组讨论会，接到第一个正式的工作任务。2014-05-21：参加企业文化培训。2014-05-29：第一次参与系统上线，主要以学习为主。2014-05-30：第一次参加组内的打羽毛球活动。2014-06-09：领取正式员工证和饭卡，之前都是拿钱买票吃饭。2014-06-10：认认真真地看书，之前都是看看博客新闻之类的文字片段，感慨“书中自有黄金屋”。2014-06-13：第一次参加公司组织的怕白云山活动。2014-07-21：开始新员工入职培训。2014-07-27：开始军训。2014-08-02：军训结束，获得优秀军训学员称号^^。2014-09-05：参与外包人员面试，第一次面试别人。2014-12-05：拿到广州市身份证^^。2015-03-06：第一次亲身经历同事离职。2015-05-08：参加公司举办的团队游戏比赛，拿到冠军！2015-08-18：参加科目一考试，考了97分。2015-10-19：好哥们结婚，请假去杭州。2015-11-03：正式提离职申请。2015-11-27：第一份工作正式结束。 收获作为人生中的第一份工作，职业生涯的起点，确实收获了很多。 1. IT技能提高 在进入职场之前，我也做个一些小的项目，主要是为了糊口并且增加项目经验。以实现项目功能为主，不会太考虑一些优化的方案或工具，遇到不会的地方就找度娘。从无到有，提高总是很快，然后能快进入“平稳期”。做后面的几个项目时，基本上还是按照原来的套路在走，感觉技能并没有提高多少。 开始上班以后，见识了以前从没见到过的平台、工具和思想。使用Linux操作系统，以前看着那一团黑乎乎的命令行shell就头疼，总觉得自己根本学不会；依赖管理可以使用Maven，想想以前手动下载依赖的做法，简直太垃圾的；可以用Spring来做IoC容器，比主动new对象不知要优雅多少倍；使用mybatis做持久化框架，终于可以把那堆恶心的sql语句给移出去了；模块化编程方式，使得耦合的代码结构变得清晰了。在回头看看自己之前写的那一顿重度耦合的代码，简直惨不忍睹！设计模式直到找工作时才去研究一下，一直不得其要领，也找不到用的时机。真正做了正经的项目之后，发现这个东西太有用了。…… 我维护的系统的需求是比较少的，平常没有活的时候，我会去主动学习研究一些东西（Python、JavaScript、CSS、JDK源代码等），从中领会到了很多东西。时常会有豁然开朗的感觉，一些以前不明白的理论、框架、思想，现在看起来是那么的自然合理。 2. 认识一群好朋友 离开了原来的大本营，在新的城市又交到了一群好朋友。正是有了他们，我才能在安心地在这里扎根。大家午休时讨论有趣的话题，有问题时也可以询问他们解决办法。正是因为有了他们，一天中除了工作之外，还有了温暖，生活变得更加丰富了。 遗憾 1. 业务积累不足 我们团队开发维护的系统是偏重于后台的，并且有好几个系统是外购的，自己手上没有源代码。而我所负责的系统是2年前开发的，虽然定义为一类系统，但是并不是公司的核心业务，不过如果出事，要背的锅就不小了。真正业务上的积累是比较少的，也就能了解一些皮毛。当然，这首先得怪自己，总是暗示自己不属于自己负责的系统范围的业务也没法去了解。其实，完全可以通过研读文档和文件来了解公司的业务。 2. 项目参与不够 自己主要负责维护一个旧的系统，可能半个月左右才会有新的需求过来，而我只开发其中的一部分需求功能，其余的交给我师父或者外包。基本上没怎么加过班，到离职时，已登记的加班时间总共也就不到40个小时。也没参与过几次上线，原则上，谁开发谁就参与上线，一共上线过5次。虽然我不喜欢加班，但是这确实说明我的项目参与是不够的。 一些改变和感触 1. 养成好的主动阅读习惯 以前更多地是被动阅读，发现问题然后找下度娘，看下与当前问题相关的文章，一旦问题解决了，从来不会再去看它了。这样就导致问题虽然解决了，但是知识仍然不属于自己。书籍是人类进步的阶梯。感觉以前读书太少了，导致知识零零碎碎的，不成系统。 由于平时活也不太多，没事的时候会下载特定知识点的电子书，看看前面的章节。如果觉得有价值，就会继续读下去，并且会做笔记。这样就能系统性的学习，把书本里的知识变成自己的了。读书的确是好习惯，必须要坚持下去！ 2. 多写 想是思维跳跃的火花，说是即兴的逻辑片段，写才是沉淀的思想体系。 自己亲自写下来的知识点才能记得更加深刻。在阅读一本好的图书、他人的分享、有价值的新闻时，我现在都会试着记下来，通常会记到有道云笔记上。这样当需要某个知识点时，能够自己的笔记中迅速地回想起来。同时，没事翻看一下以前记过的东西，可以找到自己的成长轨迹。偶然也会发现自己知识体系的不足之处，然后查阅资料补全，用写的方式推动着自己的进步。如果文字描述比较困难，也会试着用脑图软件把重要的知识点记录下来，这种方式的最终效果也是极好。 3. 多运动 工作1年多下来，明显感觉到身体不如以前了。中间有一段时间也制定了晚上一小时运动计划，只可惜仅仅执行了2个月就因为各种原因而废弃了。在运动的那段时间里，整个人都感觉特别精神，思维也比较敏捷。所以，我总结了，千万不能有一刻地放松，必须得按照既定的计划来做运动，否则身体只会越来越差。 4. 不断学习 学如逆水行舟，不进则退。 无论何时，都应该保持一颗学习的心。当然，学习不止包括技术学习这一种，还包括其他方方面面。能学的东西太多了，只有每天都不停地学习，精神才会变得充实。 新的开始现在是结束，也是新的开始，未来是可期的。定一下下一阶段的目标和期许，Fighting！！！ 技术不断进步，做到一精多专。 能交到更多的朋友 提高产品能力，为以后可能的创业道路打下基础。 写作水平，总结概括能力不断提高。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实时搜索引擎Elasticsearch（5）——Java API的使用]]></title>
      <url>%2F2015%2F11%2F28%2Felasticsearch-5%2F</url>
      <content type="text"><![CDATA[前一篇有关ES的文章介绍了使用Rest方式调用ES的聚合API。Rest API使用了HTTP协议，按理来说，可以直接使用类似HttpClient的工具直接调用Rest API。虽然笔者并没有尝试过，但稍微想想一下就知道这种方法是可行的。这种方法主要有下面几个弊端： 需要开启ES的Http服务和端口。ES提供的Http服务功能非常全面，没有提供权限控制，防护也比较脆弱。一旦遭到破解，则数据面临极大的风险。所以，建议在生产中关闭Http服务，或者自己增加一层代理来实现权限控制。 调用比较困难。Rest API的核心是url和post数据，url直接需传入字符串，这样就不能使用IDE的查错功能。需要记忆的东西太多，不确定时就要去查API，影响开发效率。 Http协议的一大特点是无连接性。也就是每一次请求都需要建立新的连接，我们知道tcp连接是比较耗时的过程。从性能的角度来说，直接使用Rest API也是不合适的。 ES所提供的Http服务适合用作集群状态和数据的监控，而不适合直接用于数据操作。ES提供了多种语言（包括Java、Python、PHP、Ruby等）版本的Client API，可以使用这些Client API编程实现数据操作功能。作为一个Java语言编程者，本文主要介绍使用Java版本的Client来操作数据。 使用Java API需要依赖ES所提供的jar包，我们使用maven来下载所需的依赖包，maven依赖定义如下： 12345&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt;&lt;/dependency&gt; version表示依赖包的版本，可以输入任意存在的版本，本文的示例中使用1.5.0版的API。注意，建议API的版本与ES集群所使用的版本保持一致，以免出现因版本不一致而导致的冲突。 本文的主要内容包括： 介绍两类Client，解释它们的之间的差异； 使用Client进行index、document和聚合相关的操作。 ClientES中所有的Java API调用都要使用Client对象，ES为API调用者提供了两类Client对象：NodeClient和TransportClient。下面来讲讲这两类Client的差异和使用场景。 NodeClientNodeClient是一种嵌入式节点客户端。它首先在客户端启动一个节点（Node），并加入同名集群内。这个节点可以保存数据，并且数据能够被索引。然后从这个节点中获取Client，这类Client就是NodeClient。NodeClient无需指明ES服务端的地址，操作的数据位于启动的节点所在的集群中。下面是获得NodeClient的代码： 12345678910111213141516171819import org.elasticsearch.client.Client;import org.elasticsearch.client.node.NodeClient;import org.elasticsearch.node.Node;import static org.elasticsearch.node.NodeBuilder.nodeBuilder;public class MyNodeClient &#123; public static void main(String[] args) &#123; // 启动一个本地节点，并加入子网内的ES集群 Node node = nodeBuilder() .clusterName("elasticsearch") // 要加入的集群名为elasticsearch // .client(true) //如果设置为true，则该节点不会保存数据 .data(true) // 本嵌入式节点可以保存数据 .node(); // 构建并启动本节点 // 获得一个Client对象，该对象可以对子网内的“elasticsearch”集群进行相关操作。 Client nodeClient = node.client(); &#125;&#125; 运行这段代码之后，可以看到工程中新增了一个data文件夹，这是因为data(true)将Node设置为可以存放数据的节点，数据正是放在了data文件夹下。 NodeClient适合用作单元或集成测试，而不适合用于生产环境。 TransportClientTransportClient连接远端的ES集群，其本身并不会加入集群。创建TransportClient的代码如下： 123456789101112131415161718192021222324import org.elasticsearch.client.Client;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.InetSocketTransportAddress;import org.elasticsearch.common.transport.TransportAddress;import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;public class MyTransportClient &#123; public static void main(String[] args) &#123; // 配置信息 Settings esSetting = settingsBuilder() .put("cluster.name", "elasticsearch") .build(); TransportClient transportClient = new TransportClient(esSetting); // 添加连接地址 TransportAddress address = new InetSocketTransportAddress("192.168.1.110", 9300); TransportAddress address2 = new InetSocketTransportAddress("192.168.1.111", 9300); transportClient.addTransportAddress(address); transportClient.addTransportAddress(address2); &#125;&#125; TransportClient适合用于生产环境中。 Index操作本小节介绍如果使用Java API创建和删除索引。 创建索引废话先不说，上代码先。下面的方法创建一个索引，并同时创建一个mapping。mapping可以传入符合格式要求的json字符串。一般情况下，我们可以使用下面的方式来生成所需的json字符串。 手动拼接json字符串 使用类似jackson的工具将对象转换为相应的json字符串 使用ES内置的XContentFactory.jsonBuilder()来创建json字符串。 本文的示例中均使用ES自带的XContentFactory.jsonBuilder()来构建json字符串。 1234567891011121314151617/** * 创建一个索引 * @param indexName 索引名 */public void createIndex(String indexName) &#123; try &#123; CreateIndexResponse indexResponse = this.client .admin() .indices() .prepareCreate(indexName) .get(); System.out.println(indexResponse.isAcknowledged()); // true表示创建成功 &#125; catch (ElasticsearchException e) &#123; e.printStackTrace(); &#125;&#125; 如果需要再索引上新建mapping，可通过下面的代码来实现。 12345678910111213141516171819202122232425262728293031323334/** * 给索引增加mapping。 * @param index 索引名 * @param type mapping所对应的type */public void addMapping(String index, String type) &#123; try &#123; // 使用XContentBuilder创建Mapping XContentBuilder builder = XContentFactory.jsonBuilder() .startObject() .field("properties") .startObject() .field("name") .startObject() .field("index", "not_analyzed") .field("type", "string") .endObject() .field("age") .startObject() .field("index", "not_analyzed") .field("type", "integer") .endObject() .endObject() .endObject(); System.out.println(builder.string()); PutMappingRequest mappingRequest = Requests.putMappingRequest(index).source(builder).type(type); this.client.admin().indices().putMapping(mappingRequest).actionGet(); &#125; catch (ElasticsearchException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 删除索引12345678910111213/** * 删除索引 * @param index 要删除的索引名 */public void deleteIndex(String index) &#123; DeleteIndexResponse deleteIndexResponse = this.client .admin() .indices() .prepareDelete(index) .get(); System.out.println(deleteIndexResponse.isAcknowledged()); // true表示成功&#125; 文档CURD操作增删改查是数据的基本操作，同时也是使用频率最高的一类操作。本小节介绍使用Java API来实现document的增删改查。 新增文档123456789101112131415161718192021222324252627282930/** * 创建一个文档 * @param index index * @param type type */public void createDoc(String index, String type) &#123; try &#123; // 使用XContentBuilder创建一个doc source XContentBuilder builder = XContentFactory.jsonBuilder() .startObject() .field("name", "zhangsan") .field("age", "lisi") .endObject(); IndexResponse indexResponse = this.client .prepareIndex() .setIndex(index) .setType(type) // .setId(id) // 如果没有设置id，则ES会自动生成一个id .setSource(builder.string()) .get(); System.out.println(indexResponse.isCreated()); &#125; catch (ElasticsearchException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 更新文档123456789101112131415161718192021222324252627282930/** * 更新文档 * @param index * @param type * @param id */public void updateDoc(String index, String type, String id) &#123; try &#123; XContentBuilder builder = XContentFactory.jsonBuilder() .startObject() .field("name", "lisi") .field("age", 12) .endObject(); UpdateResponse updateResponse = this.client .prepareUpdate() .setIndex(index) .setType(type) .setId(id) .setDoc(builder.string()) .get(); System.out.println(updateResponse.isCreated()); // true表示成功 &#125; catch (ElasticsearchException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 注意，id参数必须是确定存在的id值，否则会抛出document missing的异常。 查询文档查询文档可以是根据id查询，也可以是根据复杂的查询条件查询。根据id的get查询代码如下。 123456789101112131415/** * 根据ID查询一条数据记录。 * @param id 要查询数据的ID。 * @return 返回查询出来的记录对象的json字符串。 */public String get(String index, String type, String id) &#123; GetResponse getResponse = this.client .prepareGet() // 准备进行get操作，此时还有真正地执行get操作。（与直接get的区别） .setIndex(index) // 要查询的 .setType(type) .setId(id) .get(); return getResponse.getSourceAsString();&#125;` 基于复杂查询条件的示例代码如下。 12345678910111213141516171819202122232425/** * 使用filter方式查询数据。 * @param index 数据所在的索引名 * @param type 数据所在的type * @return */public List&lt;String&gt; queryByFilter(String index, String type) &#123; // 查询名为zhangsan的数据 FilterBuilder filterBuilder = FilterBuilders.termFilter("name", "zhangsan"); SearchResponse searchResponse = this.client .prepareSearch() .setIndices(index) .setTypes(type) .setPostFilter(filterBuilder) .get(); List&lt;String&gt; docList = new ArrayList&lt;String&gt;(); SearchHits searchHits = searchResponse.getHits(); for (SearchHit hit : searchHits) &#123; docList.add(hit.getSourceAsString()); &#125; return docList;&#125; 删除文档下面的代码删除指定id的文档。 123456789101112131415/** * 删除一条数据 * @param index * @param type * @param id */public void deleteDoc(String index, String type, String id) &#123; DeleteResponse deleteResponse = this.client .prepareDelete() .setIndex(index) .setType(type) .setId(id) .get(); System.out.println(deleteResponse.isFound()); // true表示成功&#125; 根据复杂的查询条件来删除文档。 123456789101112131415/** * 根据查询条件删除文档。 */public void deleteByQuery(String index, String type) &#123; try &#123; QueryBuilder queryBuilder = QueryBuilders.termQuery("name", "zhangsan"); DeleteByQueryResponse deleteByQueryResponse = this.client .prepareDeleteByQuery(index) .setTypes(type) .setQuery(queryBuilder) .get(); &#125; catch (ElasticsearchException e) &#123; e.printStackTrace(); &#125;&#125; 4. 聚合操作聚合操作的API稍微比较复杂一点，本文仅以min聚合的示例来说明聚合API的调用方式，其他的聚合API调用步骤类似。1234567891011121314/** * 使用min聚合查询某个字段上最小的值。 * @param index * @param type */public void min(String index, String type) &#123; SearchResponse response = this.client .prepareSearch(index) .addAggregation(AggregationBuilders.min("min").field("age")) .get(); InternalMin min = response.getAggregations().get("min"); System.out.println(min.getValue());&#125; 源代码地址：https://github.com/xialei199023/blog-demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDK源码研究——ReentrantLock浅析]]></title>
      <url>%2F2015%2F09%2F27%2Fjdk-source-learn-reentrantlock%2F</url>
      <content type="text"><![CDATA[从今天开始，要执行自己的学习计划了！！写正文之前，先发一下牢骚。前几天租的地方断网了，说是要进行城中村网络线路改造，把原来的所有的网线都暴力剪断了！搞得好几天上不了网。现在没有网络，生活中总感觉缺少点什么东西。虽然上网也干不了什么东西，但就是会觉得比较烦闷。以前没有网络的时候不也好好的嘛，所以说，互联网真的是已经深刻地改变了我们的生活，已经成为了生活中必不可少的东西。谷物是生活食量，而网络就是精神食量了。现在貌似也没有听说过“网瘾”这个词了，这个词在早些年可是一个标准的贬义词来着。看来人们的思维也是在时刻发生着变化的。废话有点多，进入正题！ 本文简单地谈一谈从JDK1.5开始引入的java.util.concurrent（简称JUC）包下的ReentrantLock类。Reentrant的英文含义是“可重入的”，也就是说ReentrantLock表示可重入的锁。这个类是用纯的java语言来实现synchronized关键字的功能，并且补充了synchronized没有实现的部分功能。由于能力有限，只能从浅层次来对ReentrantLock进行分析。本文的主要内容如下： 浅析ReentrantLock的核心源代码； 解释一下自己所理解的公平锁和非公平锁； 把ReentrantLock和synchronized做一下简单地对比。 1 ReentrantLock的核心源代码首先，感觉源代码的分析工作实在是不好做。贴太多代码吧，让人看得昏昏欲睡；不贴吧，光用文字和图片又说不太清楚。太深入吧，代码一层套一层，讲完下层还得回到上层，反正我是理解不了了。准备以自己看代码的顺序和思维方式来讲讲ReentrantLock的源代码（JDK1.7），大致的分析顺序为： 代码的整体结构 类的javadoc要点 核心内部类和方法（调用层次不超过3层）。 1.1 ReentrantLock类的整体结构首先先看一下ReentrantLock类的继承结构。类的签名如下: 1public class ReentrantLock implements Lock, java.io.Serializable ReentrantLock类实现Serializable接口,表示这个类是可以序列化和反序列话的，也就是说ReentrantLock对象可以保存到硬盘中，通过网络传输，或者其他的其他方式。实现了Lock接口表示这是锁的一种，Lock接口是一个独立的接口，没有继承其他接口。它定义了所有锁的一系列基本操作: 1234567891011void lock(); // 尝试获取锁，如果没有成功，则阻塞当前线程。void lockInterruptibly() throws InterruptedException;boolean tryLock(); // 尝试获取锁，如果不成功，则直接放弃锁，并返回false。成功的话，则加锁，并返回true。boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 尝试获取锁，然后等待time时间后仍然没有成功，则返回false。void unlock(); // 释放锁Condition newCondition(); // 创建新的Condition实例。Condition是通过Java代码实现object.wait()，object.notify()和object.notifyAll()的功能。 1.2 ReentrantLock类javadoc要点Javadoc是JDK的重要的资料和资源，通常，类和方法的一些重要信息都会在里面提及。Javadoc里面的英文还算比较好懂，是比较经典的技术文档的写好。认真研究这些Javadoc可以提高自己的文档注释能力。写一些优雅的文档和注释，应该是一个IT人员的基本素养。写好注释和文档，你好我好他也好！ 下面尝试着翻译一下ReentrantLock类javadoc。 synchronized方法或申明可以隐式地监视锁，可重入锁除了具备与其相同的基本行为和语义外，还附加了其他功能。可重入锁属于最后成功加锁，但还没有释放锁的线程。如果锁不属于其他线程，则当前线程可以通过调用lock方法成功地获取锁。如果当前线程就是锁的拥有者，那么调用lock方法就可以立刻返回。这些可以通过调用isHeldByCurrentThread和getHoldCount方法来检测。本类的构造函数能够接收一个fairness参数。如果这个参数被设置为true，则锁倾向于授予等待最久的那个线程。否则，不保证任何特定的访问顺序。如果程序中使用公平锁，当大量线程访问锁时，其吞吐量通过远小于使用非公平锁。但却有更小的时间间隔（两个线程获得锁的时间差），并且可以保证不会出现线程饥饿。然而，公平锁并不能保证线程调度的公平性。这样的话，有可能会出现同一个线程多次成功获得锁，而另外的活动线程却无法继续运行，并且当前没有持有锁的情况。注意，如果使用不限时的tryLock方法，则不遵守公平性设置。如果锁是空闲的，使用不限时的tryLock方法可以成功地获取锁，即使还有其他的锁在等待。一种值得推荐的用法是：在调用lock方法后，立刻接上try代码块。典型的用法如下： 12345678910111213* class X &#123;* private final ReentrantLock lock = new ReentrantLock();* // ...** public void m() &#123;* lock.lock(); // block until condition holds* try &#123;* // ... method body* &#125; finally &#123;* lock.unlock()* &#125;* &#125;* &#125; 除了实现了Lock接口外，本类还定义了isLocked和getLockQueueLength方法。此外，还定义了一些相关的protected级别的方法，方便记录和监控。序列化这个类的实例时，与内建的锁的行为相同。即不管序列化时对象是何种状态，反序列化后其一定是未锁定的。这种锁支持被同一个线程锁定的最大重数为2147483647。试图超过这个限制，会导致锁定时出现错误。 1.3 核心内部成员和方法分析下面列出重要的成员变量（类）和方法。 1234567private final Sync sync; // 私有的同步器类，这个类是ReentrantLock定义的内部类。final表示锁的性质一旦确定，不可更改。abstract static class Sync extends AbstractQueuedSynchronizer // 包级别的内部静态类，它集成的AbstractQueuedSynchronizer（简称A.Q.S）类是整个J.U.C包的基础，定义了带队列的同步的器的功能。它有两个子类NonfairSync（非公平同步器）和FairSync（公平的同步器），static final class NonfairSync extends Sync; // 非公平同步器static final class FairSync extends Sync； // 公平同步器 如果上面的第1行代码中sync指向NonfairSync实例，表示锁是非公平锁，如果指向FairSync实例，则表示锁为非公平锁。它们的区别会在接下的内容详细解释。下面详细地分析ReentrantLock类中的主要方法，如果可以，也会试着按照自己的理解来解释为什么要这么实现。 (1) lock()方法 这个方法直接调用sync.lock()方法，这是在Sync类的一个抽象方法，需要在子类中实现。NonfairSync和FairSync是Sync的两个实现类，lock()方法的实现就体现了这个类的差异。首先看下NonfairSync的lock()方法，该方法的源代码如下： 123456final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 第2行代码的compareAndSetState尝试修改state（0表示锁空闲，大于0表示忙）字段的值，它直接调用UnSafe类的compareAndSwapInt（简称CAS）方法，通过硬件指令来实现安全地修改变量值。如果state修改成功，则表示当前线程成功地获得锁，于是调用setExclusiveOwnerThread方法将锁的拥有者设置为当前线程。否则，调用acquire(1)方法。这是AbstractQueuedSynchronizer类的方法，该方法的源代码如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 该方法首先调用tryAcquire再一次尝试加锁，这样做的目的是尽可能地提高锁的性能。假设此时加好锁空闲，那么这样做能尽快地获取锁。这个方法是AbstractQueuedSynchronizer类中的一个protected级别的方法，方法内部直接抛出UnsupportedOperationException。这是java一个比较常用的技巧，protected修饰的方法用于继承，抛出UnsupportedOperationException异常表示方法内部没有任何的逻辑代码，全靠子类自己实现。NonfairSync和FairSync类都实现了这个方法，这个方法的实现就体现了它们之间本质性的不同。先看看NonfairSync的tryAcquire的实现，它直接调用了Sync类的nonfairTryAcquire的方法，那就直接看看这个方法代码。 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 如果当前锁空闲，则直接尝试加锁。acquires可以看做是锁的重数，如果加了n重锁，则需要释放n重锁方能完全地释放锁。 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 如果当前线程就是锁的拥有者，则直接加上acquires重锁即可。 int nextc = c + acquires; if (nextc &lt; 0) // overflow // 超过重数限制，抛出Error类型异常。超过int类型取值，则数直接变成负数。 throw new Error("Maximum lock count exceeded"); setState(nextc); // 设置新的状态 return true; &#125; return false; // 不属于上面的情况，就直接返回false。&#125; 这个方法首先查看锁是否空闲，一旦空闲，则直接尝试加锁，如果加锁成功直接返回true，否则返回false。如果锁非空闲，查看当前锁的拥有者是否为当前线程本身，如果是，则在原来的基础上加上新的重数，这就是为什么这个锁叫做可重入锁。拥有锁的线程无需再次加锁即可直接进入加锁的代码区域。下面看一下FairSync的tryAcquire的实现代码。 12345678910111213141516171819 protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 如果锁空闲，先看看等待队列里是否还有等待线程，如果没有，才尝试加锁。 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 如果当前线程就是锁的拥有者，则直接加上acquires重锁即可。 int nextc = c + acquires; if (nextc &lt; 0) // 超过重数限制，抛出Error类型异常。超过int类型取值，则数直接变成负数。 throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; // 不属于上面的情况，就直接返回false。&#125; 可以明显地看到FairSync的tryAcquire的实现与NonfairSync实现的唯一不同点就是在锁空闲时的处理方式。在锁空闲时，它不会急于抢占锁，而是先查看当前是否有线程等待，如果有，就不会去尝试加锁，那么等待队列的线程就可以获得运行机会。这与NonfairSync是完全不同的，理论上讲，NonfairSync的处理方式可能会导致等待队列里的线程永久或者很长时间无法运行，而出现线程饥饿。这两种类型的锁的区别会在接下来的内容中较为详细的介绍。 如果没有通过tryAcquire成功获取锁，则acquire方法就会调用acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法。这个方法比较复杂，也是比较独立的部分。由于本篇文章是浅析，所以不打算分析这个部分内容，搞太多东西容易让人发晕。如果真想了解这个部分的内容，可以参考这篇文章。简单点说，这个方法就是将没有成功获得锁的线程假如到等待队列，这个队列是一个阻塞队列。如果线程一直处于等待状态，直到其获得锁方可继续运行。如果没有成功的插入等待队列，则调用selfInterrupt方法直接中断当前线程。 接下来再看看FairSync的lock方法的实现。lock方法源代码如下： 123final void lock() &#123; acquire(1);&#125; 与NonfairSync的lock方法不同的是，当前线程并不会在刚开始就尝试加锁，而是直接调用acquire(1)方法。这个方法在上面已经详细解释过了，则不赘述了。 请注意，上面的方法都是final的，表示这些方法不能被子类所覆盖。 （2）tryLock()方法 该方法尝试加锁，如果没有成功，则直接作罢。它适合那些对锁的需求不是那么强烈的场景。举个例子，假设你突然觉得肚子不舒服，于是放下手中的工作跑去厕所。不巧的是，唯一的厕所已经被别人占领了，如果你还能忍得住的话，完全可以先去工作，过一段时间再来看看。这种时候使用TryAcquire是比较合适的，它不会因为加锁不成功而阻塞当前线程，这样可以提高工作效率。源代码如下： 123public boolean tryLock() &#123; return sync.nonfairTryAcquire(1); &#125; 可以惊讶得看到它直接调用nonfairTryAcquire而非tryAcquire方法，所以当前线程会尽可能地抢夺锁。 （3）unlock()方法 该方法直接释放锁，方法体内仅仅调用AbstractQueuedSynchronizer的release方法，那么就来直接看看AbstractQueuedSynchronizer的release方法代码如下： 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; // 尝试释放锁 Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) // 通知等待队列的线程，锁已释放，队首的线程可以抢锁了 unparkSuccessor(h); return true; &#125; return false; &#125; release方法首先调用tryRelease方法尝试释放锁，如果释放失败，则直接返回false。下面来看看tryRelease方法的源代码。 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; // 减去相应的重数 if (Thread.currentThread() != getExclusiveOwnerThread()) // 如果当前线程不是锁的拥有者，则抛出异常 throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; // 如果锁的state是0，则表示锁已经完全释放，将锁置为空闲状态。否则，仅仅减少锁的重数。 free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; 首先判断当前要释放锁的线程是否是锁的拥有者，如果不是直接抛出IllegalMonitorStateException，通过这个异常名就知道这是什么异常了。所以说，为要抛出的异常取好名是非常重要的，好的异常名能一眼就看出问题是什么。这就说明只有拥有锁的线程才有权释放锁，这也是自然的。只有当锁的重数为0时才算真正地释放了锁，也就是所加锁重数和放锁重数是对应的。 以上就是ReentrantLock类中的常用方法的实现，当然ReentrantLock中有一些其他的方法，这些方法实现都比较简单。 2 再谈公平锁和非公平锁从上面的源代码的分析中其实就可以看出来公平锁和非公平锁的区别在哪里，本节试着用日常化的语言和实例再来谈谈它们的区别。 非公平锁是直接尝试加锁，一旦成功，当前线程就是锁的拥有者（有可能会导致队列里的等待线程一直拿不到锁）；公平锁要先判断等待队列是否有等待线程，如果是，则当前线程不加锁而进入等待队列，那么队首线程就有机会获得锁。公平性体现在这！！ 举一个编造的例子。三国时蜀国封5虎将，分别为关羽、张飞、赵云、马超和黄忠。蜀主刘备分别为它们进行受封典礼，每次受封一名。关羽因留守荆州，姗姗入川。首先张飞进店受封，其余3人在殿外等候。张飞受封完毕，老蒋黄忠正要进殿，关羽急冲冲赶到，大喊一声：“慢！”。“让我先进去”，关羽对黄忠说。“凭啥？”，黄忠不悦，对关羽说。“吾是陛下结拜兄弟，征战多年，立下汗马功劳。其余各位均是当世英雄，汝，败军之将耳，何德何能，竟能与吾平起平坐？！”于是两人争执，均要先入。那么问题来了，谁应该先进去受封？（1）如果刘备说，你们自己抢，强者先入。那么这就是不公平的。（2）如果说，殿外等得时间最久者先入。那么就是公平的。 3 ReentrantLock和synchronized的对比ReentrantLock被设计为synchronized的Java实现，除了实现了synchronized原来的功能和语义之外，还添加了其他的额外的功能。下面来对他们进行一下对比，看看它们的适用场景。 （1）字节码 首先来看一下使用ReentrantLock的示例源代码及其编译后的字节码，直接看到字节码的第 行的代码，通过invokeinterface指令调用lock方法。invokeinterface指令是java语言调用接口方法的指令，说明ReentrantLock其实就是一个普通的Java类。 123456789101112131415public class ByteReentrantLock &#123; private Lock reentrantLock = new ReentrantLock(); public void test() &#123; reentrantLock.lock(); try &#123; &#125; catch (Exception e) &#123; &#125; finally &#123; reentrantLock.unlock(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class demo.blog.reentrant2sync.ByteReentrantLock &#123; public demo.blog.reentrant2sync.ByteReentrantLock(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: new #2 // class java/util/concurrent/locks/ReentrantLock 8: dup 9: invokespecial #3 // Method java/util/concurrent/locks/ReentrantLock.&quot;&lt;init&gt;&quot;:()V 12: putfield #4 // Field reentrantLock:Ljava/util/concurrent/locks/Lock; 15: return public void test(); Code: 0: aload_0 1: getfield #4 // Field reentrantLock:Ljava/util/concurrent/locks/Lock; 4: invokeinterface #5, 1 // InterfaceMethod java/util/concurrent/locks/Lock.lock:()V 9: aload_0 10: getfield #4 // Field reentrantLock:Ljava/util/concurrent/locks/Lock; 13: invokeinterface #6, 1 // InterfaceMethod java/util/concurrent/locks/Lock.unlock:()V 18: goto 33 21: astore_1 22: aload_0 23: getfield #4 // Field reentrantLock:Ljava/util/concurrent/locks/Lock; 26: invokeinterface #6, 1 // InterfaceMethod java/util/concurrent/locks/Lock.unlock:()V 31: aload_1 32: athrow 33: return Exception table: from to target type 21 22 21 any&#125; 接下来看一下使用synchronized关键词时的示例代码及其编译后的字节码。直接看字节码的第 行代码，使用了monitorenter指令来锁定同步块，然后再使用monitorexit退出同步块。所以，synchronized关键词是通过jvm运行时特殊指令来实现的。这与ReentrantLock的普通Java实现是不同的。 12345678public class ByteSync &#123; public void test() &#123; synchronized (this) &#123; &#125; &#125;&#125; 123456789101112131415161718192021222324252627 public demo.blog.reentrant2sync.ByteSync(); Code: 0: aload_0 1: invokespecial #1 // Meth()V 4: return public void test(); Code: 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: aload_1 5: monitorexit 6: goto 14 9: astore_2 10: aload_1 11: monitorexit 12: aload_2 13: athrow 14: return Exception table: from to target type 4 6 9 any 9 12 9 any&#125; （2）jvm支持 ReentrantLock的lock方法和unlock方法必须要成对出现的，否则会导致永久锁死。同时，为了确保unlock一定能执行，应该要将其置于finally代码块内，否则如果因出现异常而导致锁没有及时释放，后果不堪设想。ReentrantLock使用时一定要特别谨慎，否则很有可能会出现线程死锁。由于ReentrantLock就是一个普通的Java对象，那么它是可以被传递到其他的方法中的。所以ReentrantLock的锁定和解锁是可以跨方法的，或者更底层一点说是可以跨栈帧的。 synchronized关键词使用jvm指令来实现，如果synchronized代码块内出现异常，则jvm会帮我们自动解锁，不需要编程者做额外的工作，这大大减少了编码量和简化了编程的难度，同时降低了死锁的风险。可以看到monitorenter和monitorexit指令也是成对出现的，但是它们限定在同一个方法内。synchronized包裹的代码块不能跨不同的方法，也就是说synchronized是不能跨栈帧的。这制约了synchronized的适用场景，如果需要跨栈帧加锁和解锁，synchronized是不合适的。 （3）性能 由于笔者并没有Java大规模并发的实践经历，所以有关它们的性能差距只能借用别人的实验。据资料说，ReetrantLock在大规模并发的场景下性能优于synchronized，而在并发不是那么大的场景下，synchronized的性能比较高。由于没有大规模并发的条件，于是笔者借助PC做了一下小规模的并发。测试代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.concurrent.CountDownLatch;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 比较ReetrantLock与synchronized的性能区别。 * @author xialei(xialei199023@163.com) * @version v1.0 2015-9-27上午11:12:20 */public class ReetrantLockTest &#123; private int threadNum = 10; private CountDownLatch reentrantLockCdl = new CountDownLatch(threadNum); private CountDownLatch synchronizedCdl = new CountDownLatch(threadNum); private Lock lock = new ReentrantLock(); public void doReetrantLockTest() &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; threadNum; i++) &#123; new Thread() &#123; public void run() &#123; lock.lock(); try &#123; doBusiness(reentrantLockCdl); &#125; finally &#123; lock.unlock(); &#125; &#125;; &#125;.start(); &#125; try &#123; reentrantLockCdl.await(); long end = System.currentTimeMillis(); System.out.println("ReetrantLock use time : "+ (end - start)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void doSynchronized() &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; threadNum; i++) &#123; new Thread() &#123; public void run() &#123; synchronized (this) &#123; doBusiness(synchronizedCdl); &#125; &#125;; &#125;.start(); &#125; try &#123; synchronizedCdl.await(); long end = System.currentTimeMillis(); System.out.println("synchronized use time : "+ (end - start)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void doBusiness(CountDownLatch latch) &#123; for (long i = 0l; i &lt; 10000000l; i++) &#123; //System.out.println(Thread.currentThread().getName()); &#125; latch.countDown(); &#125; public static void main(String[] args) &#123; ReetrantLockTest test = new ReetrantLockTest(); test.doReetrantLockTest(); test.doSynchronized(); &#125;&#125; 测试结果如下表所示（时间单位为毫秒）： 线程并发数 ReentrantLock synchronized 1 26 23 10 218 112 50 1107 645 100 2208 1152 200 4281 2409 400 8678 4400 600 12937 6610 800 17072 8868 可以看到在小规模并发下synchronized的性能大概是ReentrantLock的2倍，这主要归功于官方对synchronized在性能上的不断完善，通过诸如偏向锁、轻量级锁等优化措施保证在小规模并发下synchronized的性能。实际上，Java官网也直接在推荐使用synchronized来做多线程同步，毕竟synchronized才是真正属于Java语言本身的。 4 总结本文着重分析了JDK1.7中的ReentrantLock源代码，包括它的Javadoc和重要的方法。通过源代码的分析，找到了公平锁和非公平锁的差异之处。ReentrantLock和synchronized是实现类似功能的不同实现，本文最后分别在字节码、jvm支持和性能这3个方面对它们进行的对比，并且说明了它们的适用场景。第一次写这种源代码的分析文章，实在是拿不准轻重，希望通过不断的写提高自己的写作能力。 参考资料： Java中的ReentrantLock和synchronized两种锁定机制的对比 AQS的原理浅析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2015-09-12总结与学习计划]]></title>
      <url>%2F2015%2F09%2F12%2Fsummary-and-plan%2F</url>
      <content type="text"><![CDATA[最近闲来无事，瞄了瞄以前看不太懂的JDK源代码，居然看起来还比较轻松！着实让我惊了一下。由此看来自己的Java水平较以前有了比较大的进步（虽然还有非常多要学习的东西）。数了数，出来工作差不多快1年半了。相比在学校的那段学习时间而言，工作之后在技术上面的进步应该是非常大的，也见识了之前从来没有接触过的东西（譬如：Linux、Elasticsearch索引、netty、jboss、zookeeper、kafka等技术）。 现在突然想总结一下工作这一段时间的一些学习上的感悟，以及学习的方法，同时也借着这个机会规划一下接下来要学习计划。虽然个人的思想也发生了比较大的变化，但是思想上的东西有点太虚幻了，目前还没有能力把这些虚幻的东西转化为有型的文字，这一点希望在坚持写博客的过程中能一点一点地提高。下面是本篇文章的要点： 总结工作一年多来的感悟。 总结一下Java中（或与Java开发相关）的知识点，对接下来的学习做一个规划。 1. 一些感悟和总结今天突然灵光一闪，脑子里面闪现出很多话，平时根本就不会发生这种事情。于是隐隐觉得这是要转变的节奏，吃完饭赶紧把它们给记下来，思如泉涌啊！！下面记录并扩展当时写下来的东西，免得过不久又忘了。PS：说到忘事这个事，真是觉得脑子远没有以前好使了，半小时之前发生的事情就有可能忘得一干二净。写一天的总结的时候，都不太记得当天都到底干了些什么，这是正常的么，还是我变蠢了？ 1、学习要找“好”时间。 有时候看一些晦涩难懂的知识点的时候，真是脑子疼啊！越是强行想要去搞懂，越是搞不懂，越是脑子疼。看着一段段感觉如“天书”版的代码，心里是抵触的，但是有时候没有办法，又必须要看懂它，结果可想而知。这是时候最好是站起身来，看看远方，然后找一些当时感兴趣的事情干干，清醒过一阵后，必会是另一番风景！等到一个合适的时机，再看看当然看不懂和不想看的东西，很有可能思路一下就打开，轻轻松松！ 我感觉一天之中总有一段时间脑子是处于半休眠的状态的，这时候如果还要强行干一些费脑的活，事倍而功半也。头脑懒惰的时候可以看一下笑话，看看别人吐吐槽，或者看下牛人们“吹吹牛”，也是一件很爽的事。当然了，作为拿老板工资的小弟，要是被老板或上司撞到在干与工作无关的事，十有八九是没有好果子吃的。我们可以换种思路嘛。要是我的话，就整整我的电脑桌面，浇一下花花草草，整整文件夹目录结构，又或者可以在原来不满意的注释上修修改改嘛。正确的时间干正确的事才是王道！ 2、看不懂的知识一定要多看几遍，总有一遍会看懂的。 在以前没有明白这个道理的时候，遇到看不懂或者理解起来比较困难的知识点就直接放弃了，使得知识浮在表面上，一知半解。这种不好的思想和习惯，直接导致了毕业找工作的时候处处碰壁，对面试官提出的问题只能侃侃而谈，一旦深入一点就完全不知所措了。 在校的时候做过一些小小的web项目，仅限于简单的CRUD操作，对于web中的核心知识从来没想要去深入地了解一下（还是因为当初学习起来比较困难，遂放弃）。于是沾沾自喜，牛气哄哄地觉得自己很牛B了，一个校招就全露馅了！经过这次的挫折我深深地感觉到自己真的是差劲！当然，我没有也不该自卑，毕竟自己还是有点智商的。 貌似扯远了,回到点上来。像原来看JVM的时候不都敢去碰，因为看得云里雾里。通过不断去看，去想，自己对它的认识也在不断地加深，看起来也相对比较轻松了，知识结构比在校的时候要强了不少。看不懂的要挑个“好”时候慢慢地一遍一遍去看，总会看懂的！ 3、温故而知新。 这一点看上去和上面那一点貌似重了，其实不然。这里的“故”我以前以为自己懂了的东西，而不是没看懂的东西。没事的时候把以前看过的觉得精彩的资料拿出来再看一下，总是会另有一番收获。 随着自己知识的增广和加深，越来越觉得所有的技术其实都是殊途同归，它们来自于同一套理论，应用于不同的场景。所以，不断地复习已经温习已有的知识，通常能对知识的理解更加深刻。科学方法无外乎归纳法和演绎法，学习知识应该要不断的归纳和总结，然后再演绎到另外陌生的知识或领域时候才能游刃有余。（说的会不会有点狗屁不通了。。）。 前人真的为我们留下了弥足珍贵的精神文化财产，值得我们去细细地学习和品味！子曰：温故而知新，可以为师矣。保留那些第一眼看过去就有价值的材料，没事的时候重新翻出来看，往往会有新的收获！ 4、技术来源于生活。 一门技术的原理来源真实的生活场景。所以在学习知识的同时，头脑里最好有一个类似的生活场景，这样理解起来要快不少。如果写的代码跟生活逻辑相悖，代码肯定有问题。假定有一面墙，我们就不能赋予它“刷墙”这个动作，因为这不是墙能主动完成的动作，它应该是被“刷”这个动作的主体所依赖的对象。这个就是面向对象的思维吧（我的理解）。 5、学习知识的时候一定有动手做笔记。 笔记不用做得太细，简单地记记就好，并且使得自己短期内能够看懂就好，之后空闲的时候可以再去完善。同时一旦有灵感，一定要找东西第一时间记下来了，不然一会就忘了！！ 6、图形胜于文字，能用图变现的东西的一定要画出来。 能用图表达的东西一定要画图，图形化的东西看起来比较轻松。图形的逻辑和表达能力比文字要高出不少。现在用的比较多的就是脑图和UML图（包括类图、序列和流程图）。 7、口说心想无凭，要记录成文。 也就是说一定要多写。脑子的容量是有限的，保存时间随着年龄的增长而变得越来越短。只有把知识点都记录下来，等得到要用的时候才能以最短的时间把它们重新拾起来。记录的方式有很多种，包括博客、云笔记等。 2. 接下来一段时间的规划规划的时间不宜过长，也不能不切实际。计划永远赶不上变化，船短好调头。过长的计划往往会因为赶不上变化而没法实现，这会打击人的信心。也不能说我一下要从初级水平跃入高级水平，这也是不可能的。饭要一口一口吃，路要一步一步走，步子迈大了，咔，扯着了蛋！ 下面定一个3个月的计划： 保证每周看一段JDK的源代码，并记录成文，发布到博客上。尽量选择那些常用的、独立成类的代码； 继续完善Elasticsearch系列文章，不必每周都写，但至少要2周发一篇。虽然写得不咋地，也没多少人看。但是没关系，说不定就能帮到别人呢！！ 把《深入理解Java虚拟机 JVM高级特性与最佳实践》再啃一遍。 下图是现在与Java相关的知识体系，希望能把这个体系慢慢扩展和加深！！ 最近一次写这么多文字貌似还是写毕业论文的时候，写起来好费力啊！！希望能够通过写博客提高自己的文字能力，不久的将来能够直接说：So easy！！加油！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实时搜索引擎Elasticsearch（4）——Aggregations （聚合）API的使用]]></title>
      <url>%2F2015%2F09%2F08%2Felasticsearch-4%2F</url>
      <content type="text"><![CDATA[上一篇博客介绍了ES中的简单查询API的使用，本篇将介绍ES提供的聚合API的使用。ES提供的聚合功能可以用来进行简单的数据分析。本文仍然以上一篇提供的数据为例来讲解。数据如下： studentNo name male age birthday classNo address isLeader 1 刘备 男 24 1985-02-03 1 湖南省长沙市 true 2 关羽 男 22 1987-08-23 2 四川省成都市 false 3 糜夫人 女 19 1990-06-12 1 上海市 false 4 张飞 男 20 1989-07-30 3 北京市 false 5 诸葛亮 男 18 1992-04-27 2 江苏省南京市 true 6 孙尚香 女 16 1994-05-21 3 false 7 马超 男 19 1991-10-20 1 黑龙江省哈尔滨市 false 8 赵云 男 23 1986-10-26 2 浙江省杭州市 false 本文的主要内容有： metric API的使用 bucketing API的使用 两类API的嵌套使用 1. 聚合APIES中的Aggregations API是从Facets功能基础上发展而来，官网正在进行替换计划，建议用户使用Aggregations API，而不是Facets API。ES中的聚合上可以分为下面两类： metric（度量）聚合：度量类型聚合主要针对的number类型的数据，需要ES做比较多的计算工作 bucketing（桶）聚合：划分不同的“桶”，将数据分配到不同的“桶”里。非常类似sql中的group语句的含义。 metric既可以作用在整个数据集上，也可以作为bucketing的子聚合作用在每一个“桶”中的数据集上。当然，我们可以把整个数据集合看做一个大“桶”，所有的数据都分配到这个大“桶”中。 ES中的聚合API的调用格式如下： 123456789&quot;aggregations&quot; : &#123; // 表示聚合操作，可以使用aggs替代 &quot;&lt;aggregation_name&gt;&quot; : &#123; // 聚合名，可以是任意的字符串。用做响应的key，便于快速取得正确的响应数据。 &quot;&lt;aggregation_type&gt;&quot; : &#123; // 聚合类别，就是各种类型的聚合，如min等 &lt;aggregation_body&gt; // 聚合体，不同的聚合有不同的body &#125; [,&quot;aggregations&quot; : &#123; [&lt;sub_aggregation&gt;]+ &#125; ]? // 嵌套的子聚合，可以有0或多个 &#125; [,&quot;&lt;aggregation_name_2&gt;&quot; : &#123; ... &#125; ]* // 另外的聚合，可以有0或多个&#125; 1.1 度量类型（metric）聚合（1）Min Aggregation 最小值查询，作用于number类型字段上。查询2班最小的年龄值。 1234567891011121314151617curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; // 可以先使用query查询得到需要的数据集 &quot;term&quot;: &#123; &quot;classNo&quot;: &quot;2&quot; &#125; &#125;, &quot;aggs&quot;: &#123; &quot;min_age&quot;: &#123; &quot;min&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125;&apos; 查询结果为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#123; "took": 19, // 前面部分数据与普通的查询数据相同 "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1.4054651, "hits": [ &#123; "_index": "student", "_type": "student", "_id": "2", "_score": 1.4054651, "_source": &#123; "studentNo": "2", "name": "关羽", "male": "男", "age": "22", "birthday": "1987-08-23", "classNo": "2", "isLeader": "false" &#125; &#125;, &#123; "_index": "student", "_type": "student", "_id": "8", "_score": 1, "_source": &#123; "studentNo": "8", "name": "赵云", "male": "男", "age": "23", "birthday": "1986-10-26", "classNo": "2", "isLeader": "false" &#125; &#125;, &#123; "_index": "student", "_type": "student", "_id": "5", "_score": 0.30685282, "_source": &#123; "studentNo": "5", "name": "诸葛亮", "male": "男", "age": "18", "birthday": "1992-04-27", "classNo": "2", "isLeader": "true" &#125; &#125; ] &#125;, "aggregations": &#123; // 聚合结果 "min_age": &#123; // 前面输入的聚合名 "value": 18, // 聚合后的数据 "value_as_string": "18.0" &#125; &#125;&#125; 上面的聚合查询有两个要注意的点： 可以通过query先过滤数据 返回的结果会包含聚合操作所作用的数据全集 有时候我们对作用的数据全集并不太敢兴趣，我们仅仅需要最终的聚合结果。可以通过查询类型（search_type）参数来实现这个需求。下面查询出来的数据量会大大减少，ES内部也会在查询时减少一些耗时的步骤，所以查询效率会提高。 1234567891011121314151617curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d // 注意这里的search_type=count&apos;&#123; &quot;query&quot;: &#123; // 可以先使用query查询得到需要的数据集 &quot;term&quot;: &#123; &quot;classNo&quot;: &quot;2&quot; &#125; &#125;, &quot;aggs&quot;: &#123; &quot;min_age&quot;: &#123; &quot;min&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125;&apos; 本次的查询结果为： 12345678910&#123;...&quot;aggregations&quot;: &#123; // 聚合结果 &quot;min_age&quot;: &#123; // 前面输入的聚合名 &quot;value&quot;: 18, // 聚合后的数据 &quot;value_as_string&quot;: &quot;18.0&quot; &#125; &#125;&#125; （2）Max Aggregation 最大值查询。下面查询2班最大的年龄值，查询结果为23。 1234567891011121314151617curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;classNo&quot;: &quot;2&quot; &#125; &#125;, &quot;aggs&quot;: &#123; &quot;max_age&quot;: &#123; &quot;max&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125;&apos; （3）Sum Aggregation 数值求和。下面统计查询2班的年龄总和，查询结果为63。 1234567891011121314151617curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;classNo&quot;: &quot;2&quot; &#125; &#125;, &quot;aggs&quot;: &#123; &quot;sum_age&quot;: &#123; &quot;sum&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125;&apos; （4）Avg Aggregation 计算平均值。下面计算查询2班的年龄平均值，结果为21。 1234567891011121314151617curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;classNo&quot;: &quot;2&quot; &#125; &#125;, &quot;aggs&quot;: &#123; &quot;avg_age&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125;&apos; （5）Stats Aggregation 统计查询，一次性统计出某个字段上的常用统计值。下面对整个学校的学生进行简单地统计。 123456789101112curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;aggs&quot;: &#123; &quot;stats_age&quot;: &#123; &quot;stats&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125;&apos; 查询结果为： 1234567891011121314151617&#123; ... // 次要数据省略 "aggregations": &#123; "stats_age": &#123; "count": 8, // 含有年龄数据的学生计数 "min": 16, // 年龄最小值 "max": 24, // 年龄最大值 "avg": 20.125, // 年龄平均值 "sum": 161, // 年龄总和 "min_as_string": "16.0", "max_as_string": "24.0", "avg_as_string": "20.125", "sum_as_string": "161.0" &#125; &#125;&#125; （6）Top hits Aggregation 取符合条件的前n条数据记录。下面查询全校年龄排在前2位的学生，仅需返回学生姓名和年龄。 1234567891011121314151617181920212223curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &#123; &quot;aggs&quot;: &#123; &quot;top_age&quot;: &#123; &quot;top_hits&quot;: &#123; &quot;sort&quot;: [ // 排序 &#123; &quot;age&quot;: &#123; // 按年龄降序 &quot;order&quot;: &quot;desc&quot; &#125; &#125; ], &quot;_source&quot;: &#123; &quot;include&quot;: [ // 指定返回字段 &quot;name&quot;, &quot;age&quot; ] &#125;, &quot;size&quot;: 2 // 取前2条数据 &#125; &#125; &#125;&#125; 返回结果为： 12345678910111213141516171819202122232425262728293031323334353637383940&#123; ... "aggregations": &#123; "top_age": &#123; "hits": &#123; "total": 9, "max_score": null, "hits": [ &#123; "_index": "student", "_type": "student", "_id": "1", "_score": null, "_source": &#123; "name": "刘备", "age": "24" &#125;, "sort": [ 24 ] &#125;, &#123; "_index": "student", "_type": "student", "_id": "8", "_score": null, "_source": &#123; "name": "赵云", "age": "23" &#125;, "sort": [ 23 ] &#125; ] &#125; &#125; &#125;&#125; 1.2 桶类型（bucketing）聚合（1）Terms Aggregation 按照指定的1或多个字段将数据划分成若干个小的区间，计算落在每一个区间上记录数量，并按指定顺序进行排序。下面统计每个班的学生数，并按学生数从大到小排序，取学生数靠前的2个班级。 12345678910111213141516curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;aggs&quot;: &#123; &quot;terms_classNo&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;classNo&quot;, // 按照班号进行分组 &quot;order&quot;: &#123; // 按学生数从大到小排序 &quot;_count&quot;: &quot;desc&quot; &#125;, &quot;size&quot;: 2 // 取前两名 &#125; &#125; &#125;&#125;&apos; 值得注意的，取得的前2名的学生数实际上是一个近似值，ES的实现方式参见这里。如果想要取得精确值，可以不指定size值，使其进行一次全排序，然后在程序中自行去取前2条记录。当然，这样做会使得ES做大量的排序运算工作，效率比较差。 （2）Range Aggregation 自定义区间范围的聚合，我们可以自己手动地划分区间，ES会根据划分出来的区间将数据分配不同的区间上去。下面将全校学生按照年龄划分为5个区间段：16岁以下、16~18、19~21、22~24、24岁以上，要求统计每一个年龄段内的学生数。 123456789101112131415161718192021222324252627282930313233curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;aggs&quot;: &#123; &quot;range_age&quot;: &#123; &quot;range&quot;: &#123; &quot;field&quot;: &quot;age&quot;, &quot;ranges&quot;: [ &#123; &quot;to&quot;: 15 &#125;, &#123; &quot;from&quot;: &quot;16&quot;, &quot;to&quot;: &quot;18&quot; &#125;, &#123; &quot;from&quot;: &quot;19&quot;, &quot;to&quot;: &quot;21&quot; &#125;, &#123; &quot;from&quot;: &quot;22&quot;, &quot;to&quot;: &quot;24&quot; &#125;, &#123; &quot;from&quot;: &quot;25&quot; &#125; ] &#125; &#125; &#125;&#125;&apos; （3）Date Range Aggregation 时间区间聚合专门针对date类型的字段，它与Range Aggregation的主要区别是其可以使用时间运算表达式。主要包括+（加法）运算、-（减法）运算和/（四舍五入）运算，每种运算都可以作用在不同的时间域上面，下面是一些时间运算表达式示例。 now+10y：表示从现在开始的第10年。 now+10M：表示从现在开始的第10个月。 1990-01-10||+20y：表示从1990-01-01开始后的第20年，即2010-01-01。 now/y：表示在年位上做舍入运算。今天是2015-09-06，则这个表达式计算结果为：2015-01-01。说好的rounding运算呢？结果是做的flooring运算，不知道为啥，估计是我理解错了-_-!! 下面查询25年前及更早出生的学生数。 1234567891011121314151617curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;aggs&quot;: &#123; &quot;range_age&quot;: &#123; &quot;date_range&quot;: &#123; &quot;field&quot;: &quot;birthday&quot;, &quot;ranges&quot;: [ &#123; &quot;to&quot;: &quot;now-25y&quot; &#125; ] &#125; &#125; &#125;&#125;&apos; （4）Histogram Aggregation 直方图聚合，它将某个number类型字段等分成n份，统计落在每一个区间内的记录数。它与前面介绍的Range聚合非常像，只不过Range可以任意划分区间，而Histogram做等间距划分。既然是等间距划分，那么参数里面必然有距离参数，就是interval参数。下面按学生年龄统计各个年龄段内的学生数量，分隔距离为2岁。 1234567891011121314curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;aggs&quot;: &#123; &quot;histogram_age&quot;: &#123; &quot;histogram&quot;: &#123; &quot;field&quot;: &quot;age&quot;, &quot;interval&quot;: 2, // 距离为2 &quot;min_doc_count&quot;: 1 // 只返回记录数量大于等于1的区间 &#125; &#125; &#125;&#125;&apos; （5）Date Histogram Aggregation 时间直方图聚合，专门对时间类型的字段做直方图聚合。这种需求是比较常用见得的，我们在统计时，通常就会按照固定的时间断（1个月或1年等）来做统计。下面统计学校中同一年出生的学生数。 1234567891011121314curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;aggs&quot;: &#123; &quot;data_histogram_birthday&quot;: &#123; &quot;date_histogram&quot;: &#123; &quot;field&quot;: &quot;birthday&quot;, &quot;interval&quot;: &quot;year&quot;, // 按年统计 &quot;format&quot;: &quot;yyyy&quot; // 返回结果的key的格式 &#125; &#125; &#125;&#125;&apos; 返回结果如下，可以看到由于上面的”format”: “yyyy”，所以返回的key_as_string只返回年的信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; "buckets": [ &#123; "key_as_string": "1985", "key": 473385600000, "doc_count": 1 &#125;, &#123; "key_as_string": "1986", "key": 504921600000, "doc_count": 1 &#125;, &#123; "key_as_string": "1987", "key": 536457600000, "doc_count": 1 &#125;, &#123; "key_as_string": "1989", "key": 599616000000, "doc_count": 1 &#125;, &#123; "key_as_string": "1990", "key": 631152000000, "doc_count": 1 &#125;, &#123; "key_as_string": "1991", "key": 662688000000, "doc_count": 1 &#125;, &#123; "key_as_string": "1992", "key": 694224000000, "doc_count": 1 &#125;, &#123; "key_as_string": "1994", "key": 757382400000, "doc_count": 1 &#125; ]&#125; （6）Missing Aggregation 值缺损聚合，它是一类单桶聚合，也就是最终只会产生一个“桶”。下面统计学生信息中地址栏缺损的记录数量。由于只有学号为6的孙尚香的地址缺损，所以统计值为1。 123456789101112curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d &apos;&#123; &quot;aggs&quot;: &#123; &quot;missing_address&quot;: &#123; &quot;missing&quot;: &#123; &quot;field&quot;: &quot;address&quot; &#125; &#125; &#125;&#125;&apos; 1.3 嵌套使用前面已经说过，聚合操作是可以嵌套使用的。通过嵌套，可以使得metric类型的聚合操作作用在每一“桶”上。我们可以使用ES的嵌套聚合操作来完成稍微复杂一点的统计功能。下面统计每一个班里最大的年龄值。 12345678910111213141516171819curl -XPOST &quot;192.168.1.101:9200/student/student/_search?search_type=count&quot; -d&apos;&#123; &quot;aggs&quot;: &#123; &quot;missing_address&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;classNo&quot; &#125;, &quot;aggs&quot;: &#123; // 在这里嵌套新的子聚合 &quot;max_age&quot;: &#123; &quot;max&quot;: &#123; // 使用max聚合 &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125; &#125; &#125;&#125;&apos; 返回结果如下： 123456789101112131415161718192021222324252627282930313233343536&#123; "buckets": [ &#123; "key": "1", // key是班级号 "doc_count": 3, // 每个班级内的人数 "max_age": &#123; // 这里是我们指定的子聚合名 "value": 24, // 每班的年龄值 "value_as_string": "24.0" &#125; &#125;, &#123; "key": "2", "doc_count": 3, "max_age": &#123; "value": 23, "value_as_string": "23.0" &#125; &#125;, &#123; "key": "3", "doc_count": 1, "max_age": &#123; "value": 20, "value_as_string": "20.0" &#125; &#125;, &#123; "key": "4", "doc_count": 1, "max_age": &#123; "value": 16, "value_as_string": "16.0" &#125; &#125; ]&#125; 2. 总结本文介绍了ES中的一些常用的聚合API的使用，包括metric、bucketing以及它们的嵌套使用方法。掌握了这些API就可以完成简单的数据统计功能，更多的API详见官方文档。前面的博客中都是介绍了ES的Rest API，接下来的文章中将会介绍Java API的使用，使用Java API可以实现前面介绍的所有API的功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实时搜索引擎Elasticsearch（3）——查询API的使用]]></title>
      <url>%2F2015%2F09%2F05%2Felasticsearch-3%2F</url>
      <content type="text"><![CDATA[上一篇文章介绍了ES中的Rest API，本章将重点介绍ES中的查询API的使用。由于笔者在实际项目仅仅将ES用作索引数据库，并没有深入研究过ES的搜索功能。而且鉴于笔者的搜索引擎知识有限，本文将仅仅介绍ES简单（非全文）的查询API。 笔者原本打算在本文中介绍聚合API的内容，但是写着写着发现文章有点过长，不便于阅读，故将聚合API的内容移至下一篇博客中。 引言单单介绍理论和API是乏味和低效率的，本文将结合一个实际的例子来介绍这些API。下表是本文数据表的表结构，表名（type）为“student”。注意，studentNo是本表的id，也就是_id字段的值与studentNo的值保持一致。 字段名 字段含义 类型 是否能被索引 备注 studentNo 学号 string 是 id name 姓名 string 是 sex 性别 string 是 age 年龄 integer 是 birthday 出生年月 date 是 address 家庭住址 string 是 classNo 班级 string 是 isLeader 是否为班干部 boolean 是 上面的表结构所对应的mapping如下，将数据保存在索引名为“student”的索引中。 123456789101112131415161718192021222324252627282930313233343536&#123; "student": &#123; "properties": &#123; "studentNo": &#123; "type": "string", "index": "not_analyzed" &#125;, "name": &#123; "type": "string", "index": "not_analyzed" &#125;, "male": &#123; "type": "string", "index": "not_analyzed" &#125;, "age": &#123; "type": "integer" &#125;, "birthday": &#123; "type": "date", "format": "yyyy-MM-dd" &#125;, "address": &#123; "type": "string", "index": "not_analyzed" &#125;, "classNo": &#123; "type": "string", "index": "not_analyzed " &#125;, "isLeader": &#123; "type": "boolean" &#125; &#125; &#125;&#125; 索引中保存的数据如下，下面介绍的所有API都将基于这个数据表。 studentNo name male age birthday classNo address isLeader 1 刘备 男 24 1985-02-03 1 湖南省长沙市 true 2 关羽 男 22 1987-08-23 2 四川省成都市 false 3 糜夫人 女 19 1990-06-12 1 上海市 false 4 张飞 男 20 1989-07-30 3 北京市 false 5 诸葛亮 男 18 1992-04-27 2 江苏省南京市 true 6 孙尚香 女 16 1994-05-21 3 false 7 马超 男 19 1991-10-20 1 黑龙江省哈尔滨市 false 8 赵云 男 23 1986-10-26 2 浙江省杭州市 false 查询APIES中的查询非常灵活，为用户提供了非常方便而强大的API。个人觉得ES的调用接口设计得非常好，所有接口合理且风格一致，值得好好研究！ Query和FilterES为用户提供两类查询API，一类是在查询阶段就进行条件过滤的query查询，另一类是在query查询出来的数据基础上再进行过滤的filter查询。这两类查询的区别是： query方法会计算查询条件与待查询数据之间的相关性，计算结果写入一个score字段，类似于搜索引擎。filter仅仅做字符串匹配，不会计算相关性，类似于一般的数据查询，所以filter得查询速度比query快。 filter查询出来的数据会自动被缓存，而query不能。 query和filter可以单独使用，也可以相互嵌套使用，非常灵活。 Query查询下面的情况下适合使用query查询： 需要进行全文搜索。 查询结果依赖于相关性，即需要计算查询串和数据的相关性。 （1）Match All Query 查询所有的数据，相当于不带条件查询。下面的代码是一个典型的match_all查询的调用方式。 12345678curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125;&apos; 查询结果如下。其他所有的查询都是返回这种格式的数据。 123456789101112131415161718192021222324252627282930313233&#123; "took": 156, // 查询耗时（毫秒） "timed_out": false, // 是否超时 "_shards": &#123; "total": 5, // 总共查询的分片数 "successful": 5, // 查询成功的分片数 "failed": 0 // 查询失败的分片数 &#125;, "hits": &#123; "total": 8, // 本次查询的记录数 "max_score": 1, // 查询所有数据中的最大score "hits": [ // 数据列表 &#123; "_index": "student", // 数据所属的索引名 "_type": "student", // 数据所属的type "_id": "4", // 数据的id值 "_score": 1, // 该记录的score "_source": &#123; // ES将原始数据保存到_source字段中 "studentNo": "4", "name": "张飞", "male": "男", "age": "20", "birthday": "1989-07-30", "classNo": "3", "isLeader": "F" &#125; &#125;, &#123; …… // 其他的数据格式相同，就不列出来了 &#125; ] &#125;&#125; 查询时，你会发现无论数据量有多大，每次最多只能查到10条数据。这是因为ES服务端默认对查询结果做了分页处理，每页默认的大小为10。如果想自己指定查询的数据，可使用from和size字段，并且按指定的字段排序。 123456789101112131415curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 2, // 从2条记录开始取 &quot;size&quot;: 4, // 取4条数据 &quot;sort&quot;: &#123; &quot;studentNo&quot;: &#123; // 按studentNo字段升序 &quot;order&quot;: &quot;asc&quot;// 降序为desc &#125; &#125; &#125;&apos; 注意：不要把from设得过大（超过10000），否则会导致ES服务端因频繁GC而无法正常提供服务。其实实际项目中也没有谁会翻那么多页，但是为了ES的可用性，务必要对分页查询的页码做一定的限制。 （2）term query 词语查询，如果是对未分词的字段进行查询，则表示精确查询。查找名为“诸葛亮”的学生，查询结果为学号为5的记录。 12345678910curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;name&quot;: &quot;诸葛亮&quot; &#125; &#125;&#125;&apos; （3）Bool Query Bool（布尔）查询是一种复合型查询，它可以结合多个其他的查询条件。主要有3类逻辑查询： must：查询结果必须符合该查询条件（列表）。 should：类似于in的查询条件。如果bool查询中不包含must查询，那么should默认表示必须符合查询列表中的一个或多个查询条件。 must_not：查询结果必须不符合查询条件（列表）。 查找2班的班干部，查询结果为学号为5的记录。 123456789101112131415161718192021curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;term&quot;: &#123; &quot;classNo&quot;: &quot;2&quot; &#125; &#125;, &#123; &quot;term&quot;: &#123; &quot;isLeader&quot;: &quot;true&quot; &#125; &#125; ] &#125; &#125;&#125;&apos; （4）Ids Query id字段查询。查询数据id值为1和2的同学，由于id的值与studentNo相同，故查询结果为学号为1和2的学生。 1234567891011121314curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;ids&quot;: &#123; &quot;type&quot;: &quot;student&quot;, &quot;values&quot;: [ &quot;1&quot;, &quot;2&quot; ] &#125; &#125;&#125;&apos; （5）Prefix Query 前缀查询。查找姓【赵】的同学，查询结果是学号为8的赵云。 12345678910curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;prefix&quot;: &#123; &quot;name&quot;: &quot;赵&quot; &#125; &#125;&#125;&apos; （6）Range Query 范围查询，针对date和number类型的数据。查找年龄到18~20岁的同学，查询结果是学号为3、4、5、7的记录。 12345678910111213curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;age&quot;: &#123; &quot;gte&quot;: &quot;18&quot;, // 表示&gt;= &quot;lte&quot;: &quot;20&quot; // 表示&lt;= &#125; &#125; &#125;&#125;&apos; 实际上，对于date类型的数据，ES中以其时间戳（长整形）的形式存放的。 （7）Terms Query 多词语查询，查找符合词语列表的数据。如果要查询的字段索引为not_analyzed类型，则terms查询非常类似于关系型数据库中的in查询。下面查找学号为1，3的学生。 12345678910111213curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;terms&quot;: &#123; &quot;studentNo&quot;: [ &quot;1&quot;, &quot;3&quot; ] &#125; &#125;&#125;&apos; （8）Wildcard Query 通配符查询，是简化的正则表达式查询，包括下面两类通配符： * 代表任意（包括0个）多个字符 ? 代表任意一个字符 查找名字的最后一个字是“亮”的同学，查询结果是学号为5的诸葛亮。 12345678910curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;wildcard&quot;: &#123; &quot;name&quot;: &quot;*亮&quot; &#125; &#125;&#125;&apos; （9）Regexp Query同学 正则表达式查询，这是最灵活的字符串类型字段查询方式。查找家住长沙市的学生，查询结果为学号为1的学生。 12345678910curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;query&quot;: &#123; &quot;regexp&quot;: &#123; &quot;address&quot;: &quot;.*长沙市.*&quot; // 这里的.号表示任意一个字符 &#125; &#125;&#125;&apos; Filter查询下面的情况下适合使用filter查询： yes/no的二元查询 针对精确值进行查询 filter和query的查询方式有不少是重叠的，所以本节仅仅介绍API的调用，一些通用的注意的事项就不再重复了。 （1）Term Filter 词语查询，如果是对未分词的字段进行查询，则表示精确查询。查找名为“诸葛亮”的学生，查询结果为学号为5的记录。 1234567891011curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;name&quot;: &quot;诸葛亮&quot;, &quot;_cache&quot; : true // 与query主要是这里的区别，可以设置数据缓存 &#125; &#125;&#125;&apos; filter查询方式都可以通过设置_cache为true来缓存数据。如果下一次恰好以相同的查询条件进行查询并且该缓存没有过期，就可以直接从缓存中读取数据，这样就大大加快的查询速度。 （2）Bool Filter 查找2班的班干部，查询结果为学号为5的记录。 123456789101112131415161718192021curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;term&quot;: &#123; &quot;classNo&quot;: &quot;2&quot; &#125; &#125;, &#123; &quot;term&quot;: &#123; &quot;isLeader&quot;: &quot;true&quot; &#125; &#125; ] &#125; &#125;&#125;&apos; （3）And Filter And逻辑连接查询，连接1个或1个以上查询条件。它与bool查询中的must查询非常相似。实际上，and查询可以转化为对应的bool查询。查找2班的班干部，查询结果为学号为5的学生。 12345678910111213141516171819curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;and&quot;: [ &#123; &quot;term&quot;: &#123; &quot;classNo&quot;: &quot;2&quot; &#125; &#125;, &#123; &quot;term&quot;: &#123; &quot;isLeader&quot;: &quot;true&quot; &#125; &#125; ] &#125;&#125;&apos; （4）Or Filter Or连接查询，表示逻辑或。。查找2班或者是班干部的学生名单，查询结果为学号为1、2、5、8的学生。 12345678910111213141516171819curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;or&quot;: [ &#123; &quot;term&quot;: &#123; &quot;classNo&quot;: &quot;2&quot; &#125; &#125;, &#123; &quot;term&quot;: &#123; &quot;isLeader&quot;: &quot;true&quot; &#125; &#125; ] &#125;&#125;&apos; （5）Exists Filter 存在查询，查询指定字段至少包含一个非null值的数据。如果字段索引为not_analyzed类型，则查询sql中的is not null查询方式。查询地址存在学生，查询结果为除了6之外的所有学生。 12345678910curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;exists&quot;: &#123; &quot;field&quot;: &quot;address&quot; &#125; &#125;&#125;&apos; （6）Missing Filter 缺失值查询，与Exists查询正好相反。查询地址不存在的学生，查询结果为学号为6的学生。 12345678910curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;missing&quot;: &#123; &quot;field&quot;: &quot;address&quot; &#125; &#125;&#125;&apos; （7）Prefix Filter 前缀查询。查找姓【赵】的同学，查询结果是学号为8的赵云。 12345678910curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;prefix&quot;: &#123; &quot;name&quot;: &quot;赵&quot; &#125; &#125;&#125;&apos; （8）Range Filter 范围查询，针对date和number类型的数据。查找年龄到18~20岁的同学，查询结果是学号为3、4、5、7的记录。 12345678910111213curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;range&quot;: &#123; &quot;age&quot;: &#123; &quot;gte&quot;: &quot;18&quot;, &quot;lte&quot;: &quot;20&quot; &#125; &#125; &#125;&#125;&apos; （9）Terms Filter 多词语查询，查找符合词语列表的数据。如果要查询的字段索引为not_analyzed类型，则terms查询非常类似于关系型数据库中的in查询。下面查找学号为1，3的学生。 12345678910111213curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;terms&quot;: &#123; &quot;studentNo&quot;: [ &quot;1&quot;, &quot;3&quot; ] &#125; &#125;&#125;&apos; （10）Regexp Filter 正则表达式查询，是最灵活的字符串类型字段查询方式。查找家住长沙市的学生，查询结果为学号为1的学生。 12345678910curl -XPOST &quot;192.168.1.101:9200/student/student/_search&quot; -d &apos;&#123; &quot;filter&quot;: &#123; &quot;regexp&quot;: &#123; &quot;address&quot;: &quot;.*长沙市.*&quot; &#125; &#125;&#125;&apos; 总结本文介绍了ES中的部分查询API，这些API是一些常用的简单API，如果需要使用更加复杂一点的API，请查阅官网文档。下一篇文章准备介绍ES中的聚合API的使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实时搜索引擎Elasticsearch（2）——Rest API的使用]]></title>
      <url>%2F2015%2F08%2F29%2Felasticsearch-2%2F</url>
      <content type="text"><![CDATA[上一篇文章简单的介绍了ES的基本概念、安装运行等内容，本文将介绍ES中的常用Rest API。 ES为开发者提供了非常丰富的基于HTTP协议的Rest API，只需要向ES服务端发送简单的Rest请求，就可以实现非常强大的功能。本篇文章主要介绍ES中常用操作的Rest API的使用，同时会讲解ES的源代码工程中的API接口文档，通过了解这个API文档的接口描述结构，就基本上可以实现ES中的绝大部分功能。 注意：查询是ES的核心。作为一个先进的搜索引擎，ES中提供了多种查询接口。本篇仅仅会涉及查询API的结构，而具体如何使用ES所提供的各种查询API，会在接下来的博文中做详细介绍。 基础知识如果之前没有用过类似于ES这样的索引数据库（暂且将ES归为数据库类，与传统的数据库有较大的区别），要理解本篇博文介绍的API是有些难度的。本节先介绍一些基础知识，对理解全文有很帮助。 Rest介绍笔者在学习软件开发过程中，多次听到过Rest Http这个概念，但在很长的一段时间里，死活搞不懂这玩意到底是个什么东西。刚开始看相关资料时，看得云里雾里，完全不知所云 _。这玩意太过于抽象和理论，心里觉得有必要搞这么复杂么。随着自己动手开发的东西越来越多，才开始对它有了一丢丢感觉。 Rest完全不是三言两语就能将清楚的，它有自己的一套体系，所以笔者打算以后单独写一些有关Rest的博文。在这里推荐一篇优秀的文章，它对Rest讲的相当清楚，本人看完之后真有醍醐灌顶的感觉！ Mapping详解Mapping是ES中的一个很重要的内容，它类似于传统关系型数据中table的schema，用于定义一个索引（index）的某个类型（type）的数据的结构。 在传统关系型数据库，我们必须首先创建table并同时定义其schema，如下面的SQL语句。下面代码中小括号内的代码的作用就是定义person_info的schema（模式）。 12345create table person_info( name varchar(20), age tinyint ) 在ES中，我们无需手动创建type（相当于table）和mapping(相关与schema)。在默认配置下，ES可以根据插入的数据自动地创建type及其mapping。在下面的API介绍部分中，会做相关的试验。当然，在实际使用过程中我们可能就想硬性规定mapping，可以通过配置文件关闭ES的自动创建mapping功能。具体配置方式见上一篇博客。 mapping中主要包括字段名、字段数据类型和字段索引类型这3个方面的定义。 字段名：这就不用说了，与传统数据库字段名作用一样，就是给字段起个唯一的名字，好让系统和用户能识别。 字段数据类型：定义该字段保存的数据的类型，不符合数据类型定义的数据不能保存到ES中。下表列出的是ES中所支持的数据类型。（大类是对所有类型的一种归类，小类是实际使用的类型。） 大类 包含的小类 String string Whole number byte, short, integer, long Floating point float, double Boolean boolean Date date 字段索引类型：索引是ES中的核心，ES之所以能够实现实时搜索，完全归功于Lucene这个优秀的Java开源索引。在传统数据库中，如果字段上建立索引，我们仍然能够以它作为查询条件进行查询，只不过查询速度慢点。而在ES中，字段如果不建立索引，则就不能以这个字段作为查询条件来搜索。也就是说，不建立索引的字段仅仅能起到数据载体的作用。string类型的数据肯定是日常使用得最多的数据类型，下面介绍mapping中string类型字段可以配置的索引类型。 索引类型 解释 analyzed 首先分析这个字符串，然后再建立索引。换言之，以全文形式索引此字段。 not_analyzed 索引这个字段，使之可以被搜索，但是索引内容和指定值一样。不分析此字段。 no 不索引这个字段。这个字段不能被搜索到。 如果索引类型设置为analyzed，在表示ES会先对这个字段进行分析（一般来说，就是自然语言中的分词），ES内置了不少分析器（analyser），如果觉得它们对中文的支持不好，也可以使用第三方分析器。由于笔者在实际项目中仅仅将ES用作普通的数据查询引擎，所以并没有研究过这些分析器。如果将ES当做真正的搜索引擎，那么挑选正确的分析器是至关重要的。 mapping中除了上面介绍的3个主要的内容外，还有其他的定义内容，详见官网文档。 常用的Rest API介绍下面介绍一下ES中的一些常用的Rest API。掌握了这些API的用法，基本上就可以简单地使用ES了。 我们需要借助能够发送HTTP请求的工具调用这些API，工具是可以任意的，包括网页浏览器。这里利用Linux上的curl命令来发送HTTP请求。基本的命令结构为： 12curl &lt;-Xaction&gt; url -d &apos;body&apos;# 这里的action表示HTTP协议中的各种动作，包括GET、POST、PUT、DELETE等。 注意。文中的示例代码里面包含了用户注释的文字，就是 # 号后面的文字。运行代码时，请注意删除这些注释。 查看集群（Cluster）信息相关API （1）查看集群健康信息。 1curl -XGET &quot;192.168.1.101:9200/_cat/heath?v&quot; 返回结果为： 12epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks 1440206633 18:23:53 elasticsearch green 1 1 0 0 0 0 0 0 返回结果的主要字段意义： cluster：集群名，是在ES的配置文件中配置的cluster.name的值。 status：集群状态。集群共有green、yellow或red中的三种状态。green代表一切正常（集群功能齐全），yellow意味着所有的数据都是可用的，但是某些复制没有被分配（集群功能齐全），red则代表因为某些原因，某些数据不可用。如果是red状态，则要引起高度注意，数据很有可能已经丢失。 node.total：集群中的节点数。 node.data：集群中的数据节点数。 shards：集群中总的分片数量。 pri：主分片数量，英文全称为private。 relo：复制分片总数。 unassign：未指定的分片数量，是应有分片数和现有的分片数的差值（包括主分片和复制分片）。 我们也可以在请求中添加help参数来查看每个操作返回结果字段的意义。 1curl -XGET &quot;192.168.1.101:9200/_cat/heath?help&quot; 返回结果如下： 123456789101112epoch | t,time | seconds since 1970-01-01 00:00:00 timestamp | ts,hms,hhmmss | time in HH:MM:SS cluster | cl | cluster name status | st | health status node.total | nt,nodeTotal | total number of nodes node.data | nd,nodeData | number of nodes that can store datashards | t,sh,shards.total,shardsTotal | total number of shards pri | p,shards.primary,shardsPrimary | number of primary shards relo | r,shards.relocating,shardsRelocating | number of relocating nodes init | i,shards.initializing,shardsInitializing | number of initializing nodes unassign | u,shards.unassigned,shardsUnassigned | number of unassigned shards pending_tasks | pt,pendingTasks | number of pending tasks 确实是很好很强大。有了这个东东，就可以减少看文档的时间。ES中许多API都可以添加help参数来显示字段含义，哪些可以这么做呢？每个API都试试就知道了。 当然，如果你觉得返回的东西太多，看着眼烦，我们也可以人为地指定返回的字段。 1curl -XGET &quot;192.168.1.101:9200/_cat/health?h=cluster,pri,relo&amp;v&quot; 这次的返回结果就简单很多罗。对于患有严重强迫症的患者来说，这是福音啊！ 12cluster pri relo elasticsearch 0 0 （2）查看集群中的节点信息。 1curl -XGET &quot;192.168.1.101:9200/_cat/nodes?v&quot; 返回节点的详细信息如下： 12host ip heap.percent ram.percent load node.role master name master.hadoop 192.168.1.101 3 35 0.00 d * Ezekiel （3）查看集群中的索引信息。 1curl -XGET &quot;192.168.1.101:9200/_cat/indices?v&quot; 返回集群中的索引信息如下： 12health status index pri rep docs.count docs.deleted store.size pri.store.size yellow open index_test 5 1 0 0 575b 575b 更多的查看和监视ES的API参见官网文档。 索引（Index）相关API（1）创建一个新的索引。 1curl -XPUT &quot;192.168.1.101:9200/index_test&quot; 如果返回下面的信息，则说明索引创建成功。如果不是，则ES会返回相应的异常信息。通常可以通过异常信息的最后一项推断出失败的原因。 123&#123; &quot;acknowledged&quot;: true&#125; 上面的操作使用默认的配置信息创建一个索引。大多数情况下，我们想在索引创建的时候就将我们所需的mapping和其他配置确定好。下面的操作就可以在创建索引的同时，创建settings和mapping。 12345678910111213141516171819202122curl -XPUT &quot;192.168.1.101:9200/index_test&quot; -d &apos; # 注意这里的&apos;号&#123; &quot;settings&quot;: &#123; &quot;index&quot;: &#123; &quot;number_of_replicas&quot;: &quot;1&quot;, # 设置复制数 &quot;number_of_shards&quot;: &quot;5&quot; # 设置主分片数 &#125; &#125;, &quot;mappings&quot;: &#123; # 创建mapping &quot;test_type&quot;: &#123; # 在index中创建一个新的type(相当于table) &quot;properties&quot;: &#123; &quot;name&quot;: &#123; # 创建一个字段（string类型数据，使用普通索引） &quot;type&quot;: &quot;string&quot;, &quot;index&quot;: &quot;not_analyzed&quot; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125; &#125; &#125; &#125;&#125;&apos; （2）删除一个索引。 1curl -XDELETE &quot;192.168.1.101:9200/index_test&quot; 如果返回与创建索引同样的信息，则说明删除成功。反之，则返回相应的异常信息。更多的索引操作参见ES官网文档。 映射（Mapping）相关API（1）创建索引的mapping。 1234567891011121314curl -XPUT &apos;localhost:9200/index_test/_mapping/test_type&apos; -d &apos; &#123; &quot;test_type&quot;: &#123; # 注意，这里的test_type与url上的test_type名保存一致 &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;index&quot;: &quot;not_analyzed&quot; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125; &#125; &#125; &#125;&apos; 如果不想单独创建mapping，可以使用上一节的方法（创建索引时创建mappings）。 假设我们的项目中有多个环境（开发环境、测试环境等），那每一个环境的mapping总要一致的吧，那每次创建一次mappings就比较麻烦了，而且还容易导致数据不一致。莫急，ES还给我们准备另外一种创建mapping的方式。可以按照下面的步骤来做。 步骤1 创建一个扩展名为test_type.json的文件名，其中type_test就是mapping所对应的type名。 步骤2 在test_type.json中输入mapping信息。假设你的mapping如下： 12345678910111213&#123; "test_type": &#123; # 注意，这里的test_type与json文件名必须一致 "properties": &#123; "name": &#123; "type": "string", "index": "not_analyzed" &#125;, "age": &#123; "type": "integer" &#125; &#125; &#125; &#125; 步骤3 在$ES_HOME/config/路径下创建mappings/index_test子目录，这里的index_test目录名必须与我们要建立的索引名一致。将test_type.json文件拷贝到index_tes目录下。 步骤4 创建index_test索引。操作如下： 1curl -XPUT &quot;192.168.1.101:9200/index_test&quot; # 注意，这里的索引名必须与mappings下新建的index_test目录名一致 这样我们就创建了一个新的索引，并且使用了test_type.json所定义的mapping作为索引的mapping。就是这么简单方便！ （2）删除mapping。 1curl -XDELETE &apos;localhost:9200/index_test/_mapping/test_type&apos; （3）查看索引的mapping。 1curl -XGET &apos;localhost:9200/index_test/_mapping/test_type&apos; 更多的mapping相关操作参加官网文档。 文档（document）相关API（1）新增一个文档。 12345curl -XPUT &apos;192.168.1.101:9200/index_test/test_type/1?pretty&apos; -d &apos; # 这里的pretty参数的作用是使得返回的json显示地更加好看。1是文档的id值（唯一键）。&#123; &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot; : &quot;12&quot;&#125;&apos; （2）更新一个文档 12345curl -XPOST &apos;192.168.1.101:9200/index_test/test_type/1?pretty&apos; -d &apos; # 这里的1必须是索引中已经存在id，否则就会变成新增文档操作&#123; &quot;name&quot;: &quot;lisi&quot;, &quot;age&quot; : &quot;12&quot;&#125;&apos; （3）删除一个文档 1curl -XDELETE &apos;192.168.1.101:9200/index_test/test_type/1?pretty&apos; # 这里的1必须是索引中已经存在id （4）查询单个文档 1curl -XGET &apos;192.168.1.101:9200/index_test/test_type/1?pretty&apos; 上面的操作仅仅查询id为1的一条文档，这样看似乎ES的查询也太弱了。前面已经说过了，查询操作是ES中的核心，是其立身的根本。但是本文的重点并不在这里，为了防止文章的篇幅过长，之后将专本介绍ES中的查询操作。 源代码中提供的Rest API文档结构ES的源代码托管在Github上。将源代码下载下来之后，里面有一个文件夹专门存放ES中绝大部分的Rest API。有了这些文档，就不必每次都要到官网上查询接口文档了（PS：ES的官网真的很慢）。下面以cat.health.json文件为例简单地介绍这些Rest API文档的结构。一旦结构搞清楚了，文档看起来就比较顺心，ES用起来就更加得心应手了！ 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;cat.health&quot;: &#123; &quot;documentation&quot;: &quot;http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-health.html&quot;, # 该文档对应的官方站点 &quot;methods&quot;: [&quot;GET&quot;], &quot;url&quot;: &#123; # url部分可选 &quot;path&quot;: &quot;/_cat/health&quot;, &quot;paths&quot;: [&quot;/_cat/health&quot;], &quot;parts&quot;: &#123; &#125;, &quot;params&quot;: &#123; &quot;local&quot;: &#123; &quot;type&quot; : &quot;boolean&quot;, &quot;description&quot; : &quot;Return local information, do not retrieve the state from master node (default: false)&quot; &#125;, &quot;master_timeout&quot;: &#123; &quot;type&quot; : &quot;time&quot;, &quot;description&quot; : &quot;Explicit operation timeout for connection to master node&quot; &#125;, &quot;h&quot;: &#123; &quot;type&quot;: &quot;list&quot;, &quot;description&quot; : &quot;Comma-separated list of column names to display&quot; &#125;, &quot;help&quot;: &#123; &quot;type&quot;: &quot;boolean&quot;, &quot;description&quot;: &quot;Return help information&quot;, &quot;default&quot;: false &#125;, &quot;ts&quot;: &#123; &quot;type&quot;: &quot;boolean&quot;, &quot;description&quot;: &quot;Set to false to disable timestamping&quot;, &quot;default&quot;: true &#125;, &quot;v&quot;: &#123; &quot;type&quot;: &quot;boolean&quot;, &quot;description&quot;: &quot;Verbose mode. Display column headers&quot;, &quot;default&quot;: true &#125; &#125; &#125;, &quot;body&quot;: null &#125;&#125; 上面文档接口所对应的Reqeust操作如下： 1curl -XGET &quot;localhost:9200/_cat/health?v&quot; -d &apos;body&apos; 该操作命令可划分为5个部分，下面把这5个部分与文档对应起来。通过这个例子，就可以在阅读其他文档后，使用正确的操作了。 第1部分（-XGET）：对应文档中methods所包含的GET操作。 第2部分（localhost:9200）：是ES服务端所在主机的hostname和port。 第3部分（/_cat/health）：对应文档中的url。其中path是最简单的url；paths是除了path之外的其他url；parts描述和解释paths里面的url的可变部分（通常用{}包裹，如{index}）。 第4部分v：表示参数，对应文档中的params。像“v”这种boolean类型的参数，不需要特意指定其布尔值（true或者false），出现即表示true，否则为false。 第5部分body：表示要传递的数据主体,对应文档中的body。如果body里面指明“required=true”,则表示必须传入body数据。具体body里面需要传怎样的数据，则可以访问文档中的documentation字段所指明的官方站点进行查询。 总结本文重点介绍了ES中的一些常用Rest API的用法，并在开始部分简单地介绍了一些基础知识（Rest和mapping）。掌握了这些API的调用，就可以利用ES完成简单的应用程序了。当然，ES的API远不止这些，如果想要更加深入地了解ES的使用及其内部原理，建议先仔细地阅读ES的官网文档。然后下载其源代码进行研究。 下一篇文章将介绍ES中查询和聚合API。由于本人在实际项目中仅仅把ES当做索引数据库，而且鉴于本人的搜索引擎的知识有限，所以仅仅会介绍ES的基本查询功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实时搜索引擎Elasticsearch（1）——基础概念、安装和运行]]></title>
      <url>%2F2015%2F08%2F15%2Felasticsearch-1%2F</url>
      <content type="text"><![CDATA[Elasticsearch（简称ES）是一个基于Apache Lucene(TM)的开源搜索引擎，无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。 Elasticsearch简介Elasticsearch是什么Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎，无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，Lucene只是一个库。想要发挥其强大的作用，你需使用Java并要将其集成到你的应用中。Lucene非常复杂，你需要深入的了解检索相关知识来理解它是如何工作的。Elasticsearch也是使用Java编写并使用Lucene来建立索引并实现搜索功能，但是它的目的是通过简单连贯的RESTful API让全文搜索变得简单并隐藏Lucene的复杂性。不过，Elasticsearch不仅仅是Lucene和全文搜索引擎，它还提供： 分布式的实时文件存储，每个字段都被索引并可被搜索 实时分析的分布式搜索引擎 可以扩展到上百台服务器，处理PB级结构化或非结构化数据 而且，所有的这些功能被集成到一台服务器，你的应用可以通过简单的RESTful API、各种语言的客户端甚至命令行与之交互。上手Elasticsearch非常简单，它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。Elasticsearch在Apache 2 license下许可使用，可以免费下载、使用和修改。随着知识的积累，你可以根据不同的问题领域定制Elasticsearch的高级特性，这一切都是可配置的，并且配置非常灵活。 以上内容来自 [百度百科] Elasticsearch中涉及到的重要概念Elasticsearch有几个核心概念。从一开始理解这些概念会对整个学习过程有莫大的帮助。 （1） 接近实时（NRT）Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒）。 （2） 集群（cluster）一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。在产品环境中显式地设定这个名字是一个好习惯，但是使用默认值来进行测试/开发也是不错的。 （3） 节点（node）一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。 一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。 在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。 （4） 索引（index）一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。索引类似于关系型数据库中Database的概念。在一个集群中，如果你想，可以定义任意多的索引。 （5） 类型（type）在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。类型类似于关系型数据库中Table的概念。 （6）文档（document）一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。在一个index/type里面，只要你想，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。文档类似于关系型数据库中Record的概念。实际上一个文档除了用户定义的数据外，还包括_index、_type和_id字段。 （7） 分片和复制（shards &amp; replicas）一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。 为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片之所以重要，主要有两方面的原因： 允许你水平分割/扩展你的内容容量 允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量 至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。 在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了。这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。复制之所以重要，主要有两方面的原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。 扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行 总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制数量，但是不能改变分片的数量。 默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。一个索引的多个分片可以存放在集群中的一台主机上，也可以存放在多台主机上，这取决于你的集群机器数量。主分片和复制分片的具体位置是由ES内在的策略所决定的。 以上部分内容转自Elasticsearch基础教程，并对其进行了补充。 Elasticsearch安装与配置安装与运行(1) 从这里下载Elasticsearch安装包。一共提供4种格式的安装包（ZIP、TAR.GZ、DEB和RPM），可以根据自己所使用的系统平台选择相应格式的安装包进行下载。（建议使用Linux系统，本人在2台windows机器上尝试启动过，一台机器上无法正常启动，另外一台可以） (2) 对下载的安装包进行解压缩即可完成安装操作。下面以在Ubuntu操作系统下使用TAR.GZ格式的1.5.0版本的安装包为例进行安装。在Linux bash中输入下面的命令解压缩。 1tar –vxf elasticsearch-1.5.0.tar.gz 安装成功，下面运行ES。 注意：Elasticsearch需要Java虚拟机的支持，在运行之前保证机器上安装了JDK，并且JDK版本不能低于1.7_55。 (3) 现在可以直接使用默认配置启动Elasticsearch了。假设安装包解压后的目录路径为【/home/elasticsearch/elasticsearch-1.5.0】，下面军用$ES_HOME来表示这个路径。执行下面的命令： 123cd /home/elasticsearch/elasticsearch-1.5.0/bin/chmod +x * ./elasticsearch 如果出现如图所示的界面（最后打印出started），则说明Elasticsearch启动成功。 下面来验证一下是否真的启动成功。打开浏览器，访问网址 http://host:9200（这里的host是ES的安装主机地址，如果安装在本机，就是http://127.0.0.1:9200）。如果显示下面的信息，则表示ES安装成功。12345678910111213&#123; "status" : 200, "name" : "Captain Zero", "cluster_name" : "elasticsearch", "version" : &#123; "number" : "1.5.0", "build_hash" : "544816042d40151d3ce4ba4f95399d7860dc2e92", "build_timestamp" : "2015-03-23T14:30:58Z", "build_snapshot" : false, "lucene_version" : "4.10.4" &#125;, "tagline" : "You Know, for Search"&#125; 上面是前台启动方式，一旦关闭Linux bash，ES服务就会停止。所以是实际使用过程中，绝对不会使用这种方式去启动ES。除了上面的启动方式外，还可以加上一定的启动参数。例如：1./elasticsearch –d #在后台运行Elasticsearch 1./elasticsearch -d -Xmx2g -Xms2g #后台启动，启动时指定内存大小（2G） 1./elasticsearch -d -Des.logger.level=DEBUG #可以在日志中打印出更加详细的信息。 ES的配置配置文件所在的目录路径如下：$ES_HOME/config/elasticsearch.yml。下面介绍一些重要的配置项及其含义。 （1）cluster.name: elasticsearch 配置elasticsearch的集群名称，默认是elasticsearch。elasticsearch会自动发现在同一网段下的集群名为elasticsearch的主机，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。生成环境时建议更改。 （2）node.name: “Franz Kafka” 节点名，默认随机指定一个name列表中名字，该列表在elasticsearch的jar包中config文件夹里name.txt文件中，其中有很多作者添加的有趣名字，大部分是漫威动漫里面的人物名字。生成环境中建议更改以能方便的指定集群中的节点对应的机器 （3）node.master: true 指定该节点是否有资格被选举成为node，默认是true，elasticsearch默认集群中的第一台启动的机器为master，如果这台机挂了就会重新选举master。 （4）node.data: true 指定该节点是否存储索引数据，默认为true。如果节点配置node.master:false并且node.data: false，则该节点将起到负载均衡的作用 （5）index.number_of_shards: 5 设置默认索引分片个数，默认为5片。经本人测试，索引分片对ES的查询性能有很大的影响，在应用环境，应该选择适合的分片大小。 （6）index.number_of_replicas: 设置默认索引副本个数，默认为1个副本。此处的1个副本是指index.number_of_shards的一个完全拷贝；默认5个分片1个拷贝；即总分片数为10。 （7）path.conf: /path/to/conf 设置配置文件的存储路径，默认是es根目录下的config文件夹。 （8）path.data:/path/to/data1,/path/to/data2 设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开。 （9）path.work:/path/to/work 设置临时文件的存储路径，默认是es根目录下的work文件夹。 （10）path.logs: /path/to/logs 设置日志文件的存储路径，默认是es根目录下的logs文件夹 （11）path.plugins: /path/to/plugins 设置插件的存放路径，默认是es根目录下的plugins文件夹 （12）bootstrap.mlockall: true 设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内存，linux下可以通过ulimit -l unlimited命令。 （13）network.bind_host: 192.168.0.1 设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0。 （14）network.publish_host: 192.168.0.1 设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。 （15）network.host: 192.168.0.1 这个参数是用来同时设置bind_host和publish_host上面两个参数。 （16）transport.tcp.port: 9300 设置节点间交互的tcp端口，默认是9300。 （17）transport.tcp.compress: true 设置是否压缩tcp传输时的数据，默认为false，不压缩。 （18）http.port: 9200 设置对外服务的http端口，默认为9200。 （19）http.max_content_length: 100mb 设置内容的最大容量，默认100mb （20）http.enabled: false 是否使用http协议对外提供服务，默认为true，开启。 （21）gateway.type: local gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的HDFS，和amazon的s3服务器，其它文件系统的设置。 （22）gateway.recover_after_nodes: 1 设置集群中N个节点启动时进行数据恢复，默认为1。 （23）gateway.recover_after_time: 5m 设置初始化数据恢复进程的超时时间，默认是5分钟。 （24）gateway.expected_nodes: 2 设置这个集群中节点的数量，默认为2，一旦这N个节点启动，就会立即进行数据恢复。 （25）cluster.routing.allocation.node_initial_primaries_recoveries: 4 初始化数据恢复时，并发恢复线程的个数，默认为4。 （26）cluster.routing.allocation.node_concurrent_recoveries: 2 添加删除节点或负载均衡时并发恢复线程的个数，默认为4。 （27）indices.recovery.max_size_per_sec: 0 设置数据恢复时限制的带宽，如入100mb，默认为0，即无限制。 （28）indices.recovery.concurrent_streams: 5 设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。 （29）discovery.zen.minimum_master_nodes: 1 设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4） （30）discovery.zen.ping.timeout: 3s 设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。 （31）discovery.zen.ping.multicast.enabled: false 设置是否打开多播发现节点，默认是true。 （32）discovery.zen.ping.unicast.hosts: [“host1”, “host2:port”, “host3 [portX-portY] “] 设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。 除了上面的在安装时配置文件中就自带的配置项外，本人在实际使用过程还使用到了下面的配置： 1234567threadpool: search: type: fixed min: 60 max: 80 queue_size: 1000// 配置es服务器的执行查询操作时所用线程池，fix固定线程数的线程池。 1234index : store: type: memory// 表示索引存储在内存中，当然es不太建议这么做。经本人测试，做查询时，使用内存索引并不会比正常的索引快。 12index.mapper.dynamic: false// 禁止自动创建mapping。默认情况下，es可以根据数据类型自动创建mapping。配置成这样，可以禁止自动创建mapping的行为。至于什么是mapping，在之后的博文中再介绍。 12index.query.parse.allow_unmapped_fields: false // 不能查找没有在mapping中定义的属性 总结本文介绍了Elasticsearch中的一些基础知识，包括其中的一些核心概念。只有理解了ES中的这些核心概念，才能对更加得心应手地使用ES，发挥其强大的搜索能力。同时，也介绍了ES的安装和运行，ES的安装和运行是很简单的，只需要极少的简单步骤，就可以开始体验ES。ES的配置非常丰富，安装时自带的配置文件只包含一部分比较核心的配置项，更多的配置内容需要自己去阅读ES的源码时才能被发现。 下一篇准备介绍ES的使用，特别是其封装的及其丰富的Rest API的使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《Effective Java》学习心得——优雅而安全地构建Java对象]]></title>
      <url>%2F2015%2F05%2F02%2Feffect-java-note-create-object%2F</url>
      <content type="text"><![CDATA[读了《Effective Java》这本书，感触良多。它刷新了我对Java语言的认识，纠正了原来的许多编程坏习惯。感叹Java的世界原来是如此丰富，内功对于一名技术人员是多么重要！本文记录本书的第2条建议——用构建器（Builder）优雅、安全地构建对象。 在Java中有多种方式可以创建对象，总结起来主要有下面的4种方式： 正常创建。通过new 操作符 反射创建。调用Class或java.lang.reflect.Constructor的newInstance()方法 克隆创建。调用现有对象的clone()方法 发序列化。调用java.io.ObjectInputStream的getObject()方法反序列化 Java对象的创建方式是其语法明确规定，用户不可能从外部改变的。本文仍然要使用上面的方式来创建对象，所以本文只能说是构建对象，而非创建对象也。 假设有这样一个场景，现在要构建一个大型的对象，这个对象包含许多个参数的对象，有些参数有些是必填的，有些则是选填的。那么如何构建优雅、安全地构建这个对象呢？ 单一构造函数通常，我们第一反应能想到的就是单一构造函数方式。直接new的方式构建，通过构造函数来传递参数，见下面的代码： 12345678910111213141516171819202122232425262728/**** 单一构造函数*/public class Person &#123; // 姓名（必填） private String name; // 年龄（必填） private int age; // 身高（选填） private int height; // 毕业学校（选填） private String school; // 爱好（选填） private String hobby; public Person(String name, int age, int height, String school, String hobby) &#123; this.name = name; this.age = age; this.height = height; this.school = school; this.hobby = hobby; &#125;&#125; 上面的构建方式有下面的缺点： 有些参数是可以选填的（如height, school），在构建Person的时候必须要传入可能并不需要的参数。 现在上面才5个参数，构造函数就已经非常长了。如果是20个参数，构造函数都可以直接上天了！ 构建的这样的对象非常容易出错。客户端必须要对照Javadoc或者参数名来讲实参传入对应的位置。如果参数都是String类型的，一旦传错参数，编译是不会报错的，但是运行结果却是错误的。 多构造函数对于第1个问题，我们可以通过构造函数重载来解决。见下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/**** 多构造函数*/public class Person &#123; // 姓名（必填） private String name; // 年龄（必填） private int age; // 身高（选填） private int height; // 毕业学校（选填） private String school; // 爱好（选填） private String hobby; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name, int age, int height) &#123; this.name = name; this.age = age; this.height = height; &#125; public Person(String name, int age, int height, String school) &#123; this.name = name; this.age = age; this.height = height; this.school = school; &#125; public Person(String name, int age, String hobby, String school) &#123; this.name = name; this.age = age; this.hobby = hobby; this.school = school; &#125;&#125; 上面的方式确实能在一定程度上降低构造函数的长度，但是却有下面的缺陷： 导致类过长。这种方式会使得Person类的构造函数成阶乘级增长。按理来说，应该要写的构造函数数是可选成员变量的组合数（实际并没有这么多，原因见第2点）。如果让我调用这样的类，绝对会在心里默念xx!! 有些参数组合无法重构。因为Java中重载是有限制的，相同方法签名的方法不能构成重载，编译时无法通过。譬如包含（name, age, school）和(name, age, hobby)的构造函数是不能重载的，因为shcool和hobby同为String类型。Java只认变量的类型，管你变量是什么含义呢。 （看脸的社会唉） JavaBean方式上面的方法不行，莫急！还有法宝——JavaBean。一个对象的构建通过多个方法来完成。直接见下面的代码： 12345678910111213141516171819202122232425262728293031323334public class Person &#123; // 姓名（必填） private String name; // 年龄（必填） private int age; // 身高（选填） private int height; // 毕业学校（选填） private String school; // 爱好（选填） private String hobby; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public void setSchool(String school) &#123; this.school = school; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125; 客户端使用这个对象的代码如下： 123456789public class Client &#123; public static void main(String[] args) &#123; Person person = new Person(&quot;james&quot;, 12); person.setHeight(170); person.setHobby(&quot;reading&quot;); person.setSchool(&quot;xxx university&quot;); &#125;&#125; 这样看起来完美的解决了Person对象构建的问题，使用起来非常优雅便捷。确实，在单一线程的环境中这确实是一个非常好的构建对象的方法，但是如果是在多线程环境中仍有其致命缺陷。在多线程环境中，这个对象不能安全地被构建，因为它不是不可变对象。一旦Person对象被构建，我们随时可通过setXXX()方法改变对象的内部状态。假设有一个线程正在执行与Person对象相关的业务方法，另外一个线程改变了其内部状态，这样得到莫名其妙的结果。由于线程运行的无规律性，使得这问题有可能不能重现，这个时候真的就只能哭了。（程序员真苦逼。。。） Builder方式为了完美地解决这个问题，下面引出本文中的主角（等等等等！）。我们使用构建器（Builder）来优雅、安全地构建Person对象。废话不说，直接代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * 待构建的对象。该对象的特点： * &lt;ol&gt; * &lt;li&gt;需要用户手动的传入多个参数，并且有多个参数是可选的、顺序随意&lt;/li&gt; * &lt;li&gt;该对象是不可变的（所谓不可变，就是指对象一旦创建完成，其内部状态不可变，更通俗的说是其成员变量不可改变）。 * 不可变对象本质上是线程安全的。&lt;/li&gt; * &lt;li&gt;对象所属的类不是为了继承而设计的。&lt;/li&gt; * &lt;/ol&gt; * 满足上面特点的对象的构建可是使用下面的Build方式构建。这样构建对象有下面的好处： * &lt;ol&gt; * &lt;li&gt;不需要写多个构造函数，使得对象的创建更加便捷&lt;/li&gt; * &lt;li&gt;创建对象的过程是线程安全的&lt;/li&gt; * &lt;/ol&gt; * @author xialei * @date 2015-5-2 */public class Person &#123; // 姓名（必填），final修饰name一旦被初始化就不能再改变，保证了对象的不可变性。 private final String name; // 年龄（必填） private final int age; // 身高（选填） private final int height; // 毕业学校（选填） private final String school; // 爱好（选填） private final String hobby; /** * 这个私有构造函数的作用： * &lt;ol&gt; * &lt;li&gt;成员变量的初始化。final类型的变量必须进行初始化，否则无法编译成功&lt;/li&gt; * &lt;li&gt;私有构造函数能够保证该对象无法从外部创建，并且Person类无法被继承&lt;/li&gt; * &lt;/ol&gt; */ private Person(String name, int age, int height, String school, String hobby) &#123; this.name = name; this.age = age; this.height = height; this.school = school; this.hobby = hobby; &#125; /** * 要执行的动作 */ public void doSomething() &#123; // TODO do what you want!! &#125; /** * 构建器。为什么Builder是内部静态类？ * &lt;ol&gt; * &lt;li&gt;必须是Person的内部类。否则，由于Person的构造函数私有，不能通过new的方式创建Person对象&lt;/li&gt; * &lt;li&gt;必须是静态类。由于Person对象无法从外部创建，如果不是静态类，则外部无法引用Builder对象。&lt;/li&gt; * &lt;/ol&gt; * &lt;b&gt;注意&lt;/b&gt;：Builder内部成员变量要与Person的成员变量保持一致。 * @author xialei * */ public static class Builder &#123; // 姓名（必填）。注意：这里不能是final的 private String name; // 年龄（必填） private int age; // 身高（选填） private int height; // 毕业学校（选填） private String school; // 爱好（选填） private String hobby; public Builder(String name, int age) &#123; this.name = name; this.age = age; &#125; public Builder setHeight(int height) &#123; this.height = height; return this; &#125; public Builder setSchool(String school) &#123; this.school = school; return this; &#125; public Builder setHobby(String hobby) &#123; this.hobby = hobby; return this; &#125; /** * 构建对象 * @return 返回待构建的对象本身 */ public Person build() &#123; return new Person(name, age, height, school, hobby); &#125; &#125;&#125; 客户端构建对象的方式见下面的代码： 123456789101112131415161718/** * 使用Person对象的客户端 * @author xialei * @date 2015-5-2 */public class Client &#123; public static void main(String[] args) &#123; /* * 通过链式调用的方式创建Person对象，非常优雅！ */ Person person = new Person.Builder(&quot;james&quot;, 12) .setHeight(170) .setHobby(&quot;reading&quot;) .build(); person.doSomething(); &#125;&#125; 如果不想看代码，可看下面对于上面代码的总结： 通过private Person(..)使得Person类不可被继承 通过将Person类的成员变量设置为final类型，使得其不可变 通过Person内部的static Builder类来构建Person对象 通过将Builder类内部的setXXX()方法返回Builder类型本身，实现链式调用构建Person对象 总结至此，我们就相对完美地解决这一类型的对象创建问题！下面来总结一下本文的重点。待创建的对象特点： 需要用户手动的传入多个参数，并且有多个参数是可选的、顺序任意 对象不可变 对象所属的类不是为了继承而设计的。即类不能被继承 依次使用的对象构建方法： 单一构造函数 多构造函数 JavaBean方式 Builder方式 最终，通过比较得出Builder方法最为合适的解决。 附注 第一次写博客，现在才发现原来写博文真心是一件耗时耗力的事情。原来遇到问题都是第一时间搜索别人的博文，然后无偿窃取别人的劳动成果，觉得很惭愧！向那些将自己的研究成果无偿贡献给大众的牛人致敬！以后自己也要坚持地写下去！@2015-05-02注！]]></content>
    </entry>

    
  
  
</search>
